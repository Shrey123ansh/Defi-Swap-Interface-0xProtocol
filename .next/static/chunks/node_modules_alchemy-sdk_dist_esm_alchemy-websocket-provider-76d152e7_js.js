/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_alchemy-sdk_dist_esm_alchemy-websocket-provider-76d152e7_js"],{

/***/ "./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyProvider\": function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-bb84a433.js */ \"./node_modules/alchemy-sdk/dist/esm/index-bb84a433.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/networks */ \"./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/providers */ \"./node_modules/@ethersproject/providers/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/web */ \"./node_modules/@ethersproject/web/lib.esm/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__._)(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__._)(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        let connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Add user provided overrides if they exist.\r\n        if (config.connectionInfoOverrides) {\r\n            connection = Object.assign(Object.assign({}, connection), config.connectionInfoOverrides);\r\n        }\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.E[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n        this.modifyFormatter();\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.D;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.C) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_3__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.a;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.N).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.N).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.g)(network, apiKey)\r\n            : (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.b)(network, apiKey);\r\n        return {\r\n            headers: _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.I\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.V\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.V,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__._)(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.l)('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.D;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.d)(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */\r\n    modifyFormatter() {\r\n        this.formatter.formats['receiptLog']['removed'] = val => {\r\n            if (typeof val === 'boolean') {\r\n                return val;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\n\n//# sourceMappingURL=alchemy-provider-c13827af.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS1wcm92aWRlci1jMTM4MjdhZi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwUTtBQUNyTjtBQUNNO0FBQ1o7QUFDMUI7QUFDYTtBQUNuQjtBQUMyQjtBQUNYO0FBQ0c7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsVUFBVSxtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQix1Q0FBdUMsOEJBQThCLDBDQUEwQyxHQUFHO0FBQ3hNO0FBQ0EsbUJBQW1CLDZEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaURBQWM7QUFDcEUsbUJBQW1CLGlEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG1FQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWU7QUFDbEM7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMsaURBQU87QUFDcEQ7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxtQkFBbUIsY0FBYyxpREFBTyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFpQjtBQUMvQixjQUFjLHFEQUFlO0FBQzdCO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0Esa0RBQWtELGlEQUFPO0FBQ3pEO0FBQ0E7QUFDQSxrREFBa0QsaURBQU87QUFDekQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVCxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUF1QjtBQUN0RDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvZXNtL2FsY2hlbXktcHJvdmlkZXItYzEzODI3YWYuanM/OGFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9fYXdhaXRlciwgRCBhcyBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSwgQyBhcyBDdXN0b21OZXR3b3JrcywgYSBhcyBERUZBVUxUX05FVFdPUkssIE4gYXMgTmV0d29yaywgSSBhcyBJU19CUk9XU0VSLCBWIGFzIFZFUlNJT04sIGwgYXMgbG9nV2FybiwgZCBhcyBkZWVwQ29weSwgRSBhcyBFdGhlcnNOZXR3b3JrLCBnIGFzIGdldEFsY2hlbXlIdHRwVXJsLCBiIGFzIGdldEFsY2hlbXlXc1VybCB9IGZyb20gJy4vaW5kZXgtYmI4NGE0MzMuanMnO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJztcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tICdAZXRoZXJzcHJvamVjdC93ZWInO1xuaW1wb3J0ICcuL2FwaS91dGlscyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgJ2F4aW9zJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC93YWxsZXQnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnO1xuXG4vKiogTWF4aW11bSBzaXplIG9mIGEgYmF0Y2ggb24gdGhlIHJwYyBwcm92aWRlci4gKi9cclxuY29uc3QgREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFID0gMTAwO1xyXG4vKiogVGltZW91dCBpbnRlcnZhbCBiZWZvcmUgdGhlIHBlbmRpbmcgYmF0Y2ggaXMgc2VudC4gKi9cclxuY29uc3QgREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TID0gMTA7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjbGFzcyB0byBlbnF1ZXVlIHJlcXVlc3RzIGFuZCBhdXRvbWF0aWNhbGx5IHNlbmQvcHJvY2VzcyBiYXRjaGVzLlxyXG4gKlxyXG4gKiBUaGUgdW5kZXJseWluZyBiYXRjaGluZyBtZWNoYW5pc20gaXMgbG9vc2VseSBiYXNlZCBvbiBldGhlcnMuanMnc1xyXG4gKiBgSnNvblJwY0JhdGNoUHJvdmlkZXJgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlcXVlc3RCYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlbmRCYXRjaEZuLCBtYXhCYXRjaFNpemUgPSBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUpIHtcclxuICAgICAgICB0aGlzLnNlbmRCYXRjaEZuID0gc2VuZEJhdGNoRm47XHJcbiAgICAgICAgdGhpcy5tYXhCYXRjaFNpemUgPSBtYXhCYXRjaFNpemU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkgb2YgZW5xdWV1ZWQgcmVxdWVzdHMgYWxvbmcgd2l0aCB0aGUgY29uc3RydWN0ZWQgcHJvbWlzZSBoYW5kbGVycyBmb3JcclxuICAgICAgICAgKiBlYWNoIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgdGhlIHByb3ZpZGVkIHJlcXVlc3QuIFRoZSBiYXRjaCBpcyBpbW1lZGlhdGVseSBzZW50IGlmIHRoZSBtYXhpbXVtXHJcbiAgICAgKiBiYXRjaCBzaXplIGlzIHJlYWNoZWQuIE90aGVyd2lzZSwgdGhlIHJlcXVlc3QgaXMgZW5xdWV1ZWQgb250byBhIGJhdGNoIHRoYXRcclxuICAgICAqIGlzIHNlbnQgYWZ0ZXIgMTBtcy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoLmxlbmd0aCA9PT0gdGhpcy5tYXhCYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbmQgYmF0Y2ggaW1tZWRpYXRlbHkgaWYgd2UgYXJlIGF0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUuXHJcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBiYXRjaCBmb3IgbmV4dCBldmVudCBsb29wICsgc2hvcnQgZHVyYXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpLCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudGx5IHF1ZXVlZCBiYXRjaGVzIGFuZCByZXNldHMgdGhlIGJhdGNoIGFuZCB0aW1lci4gUHJvY2Vzc2VzXHJcbiAgICAgKiB0aGUgYmF0Y2hlZCByZXNwb25zZSByZXN1bHRzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHByb21pc2VzLlxyXG4gICAgICovXHJcbiAgICBzZW5kQmF0Y2hSZXF1ZXN0KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xyXG4gICAgICAgICAgICAvLyBnbyBpbnRvIHRoZSBuZXh0IGJhdGNoXHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5wZW5kaW5nQmF0Y2g7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQmF0Y2hUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gYmF0Y2gubWFwKGluZmxpZ2h0ID0+IGluZmxpZ2h0LnJlcXVlc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQmF0Y2hGbihyZXF1ZXN0KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCByZXN1bHQsIGZlZWQgaXQgdG8gdGhlIGNvcnJlY3QgUHJvbWlzZSwgZGVwZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBvbiB3aGV0aGVyIGl0IHdhcyBhIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaChpbmZsaWdodFJlcXVlc3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGxldCBjb25uZWN0aW9uID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnaHR0cCcpO1xyXG4gICAgICAgIC8vIElmIGEgaGFyZGNvZGVkIHVybCB3YXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlXHJcbiAgICAgICAgLy8gcHJvdmlkZWQgYXBpS2V5IG9yIG5ldHdvcmsuXHJcbiAgICAgICAgaWYgKGNvbmZpZy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIC8vIEFkZCB1c2VyIHByb3ZpZGVkIG92ZXJyaWRlcyBpZiB0aGV5IGV4aXN0LlxyXG4gICAgICAgIGlmIChjb25maWcuY29ubmVjdGlvbkluZm9PdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbiksIGNvbmZpZy5jb25uZWN0aW9uSW5mb092ZXJyaWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgZXRoZXJzTmV0d29yayk7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IGNvbmZpZy5iYXRjaFJlcXVlc3RzO1xyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgaW5kaXZpZHVhbCBoZWFkZXJzIHdoZW4gY2FsbGluZyBiYXRjaFxyXG4gICAgICAgIGNvbnN0IGJhdGNoZXJDb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pLCB7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uLmhlYWRlcnMpLCB7ICdBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJzogJ2JhdGNoU2VuZCcgfSkgfSk7XHJcbiAgICAgICAgY29uc3Qgc2VuZEJhdGNoRm4gPSAocmVxdWVzdHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoSnNvbihiYXRjaGVyQ29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlciA9IG5ldyBSZXF1ZXN0QmF0Y2hlcihzZW5kQmF0Y2hGbik7XHJcbiAgICAgICAgdGhpcy5tb2RpZnlGb3JtYXR0ZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgVXJsSnNvblJwY1Byb3ZpZGVyLmdldEFwaUtleWAgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5XHJcbiAgICAgKiBldGhlcnMuanMuIFJldHVybnMgdGhlIEFQSSBrZXkgZm9yIGFuIEFsY2hlbXkgcHJvdmlkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcclxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiBhcGlLZXkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcGlLZXkgJyR7YXBpS2V5fScgcHJvdmlkZWQuIGFwaUtleSBtdXN0IGJlIGEgc3RyaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBpS2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBCYXNlUHJvdmlkZXIuZ2V0TmV0d29ya2AgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG92ZXJyaWRlIGFsbG93cyB0aGUgU0RLIHRvIHNldCB0aGUgcHJvdmlkZXIncyBuZXR3b3JrIHRvIHZhbHVlcyBub3RcclxuICAgICAqIHlldCBzdXBwb3J0ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmcnICYmIG5ldHdvcmsgaW4gQ3VzdG9tTmV0d29ya3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbU5ldHdvcmtzW25ldHdvcmtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHRoZSBzdGFuZGFyZCBldGhlcnMuanMgZ2V0TmV0d29yayBtZXRob2QgZm9yIG90aGVyIG5ldHdvcmtzLlxyXG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgYE5ldHdvcmtpc2hgIGlucHV0IHRvIHRoZSBuZXR3b3JrIGVudW0gdXNlZCBieSBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QWxjaGVteU5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmIChuZXR3b3JrID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfTkVUV09SSztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV0d29yayAnJHtuZXR3b3JrfScgcHJvdmlkZWQuIE5ldHdvcmsgbXVzdCBiZSBhIHN0cmluZy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR3VhcmFudGVlZCB0aGF0IGB0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZ2AuXHJcbiAgICAgICAgY29uc3QgaXNWYWxpZE5ldHdvcmsgPSBPYmplY3QudmFsdWVzKE5ldHdvcmspLmluY2x1ZGVzKG5ldHdvcmspO1xyXG4gICAgICAgIGlmICghaXNWYWxpZE5ldHdvcmspIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5ldHdvcmsgJyR7bmV0d29ya30nIHByb3ZpZGVkLiBOZXR3b3JrIG11c3QgYmUgb25lIG9mOiBgICtcclxuICAgICAgICAgICAgICAgIGAke09iamVjdC52YWx1ZXMoTmV0d29yaykuam9pbignLCAnKX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXR3b3JrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIENvbm5lY3Rpb25JbmZvfSBvYmplY3QgY29tcGF0aWJsZSB3aXRoIGV0aGVycyB0aGF0IGNvbnRhaW5zXHJcbiAgICAgKiB0aGUgY29ycmVjdCBVUkxzIGZvciBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvKG5ldHdvcmssIGFwaUtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IHR5cGUgPT09ICdodHRwJ1xyXG4gICAgICAgICAgICA/IGdldEFsY2hlbXlIdHRwVXJsKG5ldHdvcmssIGFwaUtleSlcclxuICAgICAgICAgICAgOiBnZXRBbGNoZW15V3NVcmwobmV0d29yaywgYXBpS2V5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBJU19CUk9XU0VSXHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAnQWxjaGVteS1FdGhlcnMtU2RrLVZlcnNpb24nOiBWRVJTSU9OXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQWxjaGVteS1FdGhlcnMtU2RrLVZlcnNpb24nOiBWRVJTSU9OLFxyXG4gICAgICAgICAgICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcclxuICAgICAgICAgICAgdXJsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBtZXRob2QgaW4gZXRoZXJzLmpzJ3MgYFN0YXRpY0pzb25ScGNQcm92aWRlcmAgY2xhc3MuIFRoaXNcclxuICAgICAqIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBjYWxsaW5nIG1ldGhvZHMgb24gdGhlIHBhcmVudCBjbGFzcyBgQmFzZVByb3ZpZGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZGV0ZWN0TmV0d29yaygpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgZGV0ZWN0TmV0d29yazogeyBnZXQ6ICgpID0+IHN1cGVyLmRldGVjdE5ldHdvcmsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xyXG4gICAgICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgX3N1cGVyLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbmV0d29yayBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3N0YXJ0UGVuZGluZygpIHtcclxuICAgICAgICBsb2dXYXJuKCdXQVJOSU5HOiBBbGNoZW15IFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgcGVuZGluZyBmaWx0ZXJzJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgZXRoZXIncyBgaXNDb21tdW5pdHlSZXNvdXJjZSgpYCBtZXRob2QuIFJldHVybnMgdHJ1ZSBpZiB0aGVcclxuICAgICAqIGN1cnJlbnQgYXBpIGtleSBpcyB0aGUgZGVmYXVsdCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpS2V5ID09PSBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBiYXNlIHtAbGluayBKc29uUnBjUHJvdmlkZXIuc2VuZH0gbWV0aG9kIHRvIGltcGxlbWVudCBjdXN0b21cclxuICAgICAqIGxvZ2ljIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgbWV0aG9kIG5hbWUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBBZGQgaGVhZGVycyBmb3IgYHBlcmZvcm0oKWAgb3ZlcnJpZGUuXHJcbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQobWV0aG9kLCBwYXJhbXMsICdzZW5kJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEpzb25ScGNQcm92aWRlci5zZW5kKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBjdXN0b20gaGVhZGVyc1xyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc2VuZChtZXRob2QsIHBhcmFtcywgbWV0aG9kTmFtZSwgZm9yY2VCYXRjaCA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0SWQrKyxcclxuICAgICAgICAgICAganNvbnJwYzogJzIuMCdcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNUQVJUIE1PRElGSUVEIENPREVcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uKTtcclxuICAgICAgICBjb25uZWN0aW9uLmhlYWRlcnNbJ0FsY2hlbXktRXRoZXJzLVNkay1NZXRob2QnXSA9IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hSZXF1ZXN0cyB8fCBmb3JjZUJhdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhdGNoZXIuZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgYWN0aW9uOiAncmVxdWVzdCcsXHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxyXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxyXG4gICAgICAgIC8vIGFyZSB0aGUgYmlnZ2VzdCB3aW5zIGFuZCBkbyBub3QgcmVxdWlyZSBhbnkgc2VyaWFsaXppbmcgcGFyYW1ldGVycy5cclxuICAgICAgICBjb25zdCBjYWNoZSA9IFsnZXRoX2NoYWluSWQnLCAnZXRoX2Jsb2NrTnVtYmVyJ10uaW5kZXhPZihtZXRob2QpID49IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW21ldGhvZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Jlc3BvbnNlJyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcclxuICAgICAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gVGhpcyBpcyBkb25lIGJ5IGV0aGVycy5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBiYXNlIGBGb3JtYXR0ZXJgIGNsYXNzIGluaGVyaXRlZCBmcm9tIGV0aGVycyB0byBzdXBwb3J0XHJcbiAgICAgKiByZXR1cm5pbmcgY3VzdG9tIGZpZWxkcyBpbiBFdGhlcnMgcmVzcG9uc2UgdHlwZXMuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGNvbnRleHQsIGV0aGVycyBoYXMgYSBgRm9ybWF0dGVyYCBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gZm9ybWF0IHRoZVxyXG4gICAgICogcmVzcG9uc2UgZnJvbSBhIEpTT04tUlBDIHJlcXVlc3QuIEFueSBmaWVsZHMgdGhhdCBhcmUgbm90IGRlZmluZWQgaW4gdGhlXHJcbiAgICAgKiBgRm9ybWF0dGVyYCBjbGFzcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZXR1cm5lZCByZXNwb25zZS4gQnkgbW9kaWZ5aW5nIHRoZVxyXG4gICAgICogYEZvcm1hdHRlcmAgY2xhc3MgaW4gdGhpcyBtZXRob2QsIHdlIGNhbiBhZGQgc3VwcG9ydCBmb3IgZmllbGRzIHRoYXQgYXJlXHJcbiAgICAgKiBub3QgZGVmaW5lZCBpbiBldGhlcnMuXHJcbiAgICAgKi9cclxuICAgIG1vZGlmeUZvcm1hdHRlcigpIHtcclxuICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXRzWydyZWNlaXB0TG9nJ11bJ3JlbW92ZWQnXSA9IHZhbCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMnc1xyXG4gKiBgQGV0aGVyc3Byb2plY3Qvd2ViL3NyYy50cy9pbmRleC50c2AuIFVzZWQgdG8gc3VwcG9ydFxyXG4gKiB7QGxpbmsgQWxjaGVteVByb3ZpZGVyLl9zZW5kfSwgd2hpY2ggaXMgYWxzbyBjb3BpZWQgb3Zlci5cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XHJcbiAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcclxuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xyXG59XG5cbmV4cG9ydCB7IEFsY2hlbXlQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci1jMTM4MjdhZi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js\n"));

/***/ }),

/***/ "./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-76d152e7.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-76d152e7.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyWebSocketProvider\": function() { return /* binding */ AlchemyWebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-bb84a433.js */ \"./node_modules/alchemy-sdk/dist/esm/index-bb84a433.js\");\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ \"./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/providers */ \"./node_modules/@ethersproject/providers/lib.esm/index.js\");\n/* harmony import */ var _alchemy_provider_c13827af_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alchemy-provider-c13827af.js */ \"./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                ((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [(0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.t)(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.t)(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(oldLog.blockNumber),\r\n                        logIndex: (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.t)(fromBlockInclusive), toBlock: (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.t)(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = _alchemy_provider_c13827af_js__WEBPACK_IMPORTED_MODULE_3__.AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = _alchemy_provider_c13827af_js__WEBPACK_IMPORTED_MODULE_3__.AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = _alchemy_provider_c13827af_js__WEBPACK_IMPORTED_MODULE_3__.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.V}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.E[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.n;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.C) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if ((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.i)(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.i)(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.i)(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.i)(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if ((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.i)(eventName)) {\r\n            (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.v)(eventName);\r\n            const event = new _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.c((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.e)(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [..._index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.A, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if ((0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.i)(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.e)(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.A.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.A.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.h) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.j.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.k) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.j.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.h:\r\n                return result => this.emit({\r\n                    method: _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.j.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.k:\r\n                return result => this.emit({\r\n                    method: _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.j.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.e)(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.e)(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.e)(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.e)(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket) : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_1__.f)(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\n\n//# sourceMappingURL=alchemy-websocket-provider-76d152e7.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItNzZkMTUyZTcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMFo7QUFDM1c7QUFDTTtBQUNBO0FBQ1E7QUFDSTtBQUM1QztBQUNOO0FBQzJCO0FBQ1g7QUFDRztBQUNOOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscURBQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFPO0FBQ3RDLDJEQUEyRCxVQUFVLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFPO0FBQ3hCLG9CQUFvQixxREFBTztBQUMzQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQSxtQkFBbUIscURBQU87QUFDMUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxxQkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0JBQXNCO0FBQ25FO0FBQ0E7QUFDQSw2QkFBNkIscURBQUs7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBLDhEQUE4RCxxREFBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0EsZ0JBQWdCLHFEQUFLO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0Esd0RBQXdELHFEQUFPO0FBQy9EO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQscURBQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxREFBTztBQUM1QyxrQ0FBa0MscURBQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLFdBQVcscURBQUssK0JBQStCLHFEQUFLLHdCQUF3QjtBQUN2SjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixHQUFHLGVBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZSxVQUFVLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUVBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9GQUF5QjtBQUNoRDtBQUNBLCtCQUErQiw0RkFBaUM7QUFDaEUsMkJBQTJCLG1HQUF3QztBQUNuRSx3Q0FBd0MsaURBQU8sQ0FBQztBQUNoRDtBQUNBLHVCQUF1Qix3REFBZTtBQUN0QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RCw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RCw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNEJBQTRCLHFEQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsdUJBQXVCO0FBQzdGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaURBQWM7QUFDcEUsbUJBQW1CLGlEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG1FQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsU0FBUyxpQkFBaUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFEQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxREFBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscURBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWM7QUFDMUIsWUFBWSxxREFBc0I7QUFDbEMsOEJBQThCLGlEQUFXLENBQUMscURBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUF1QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUE0QjtBQUN4QztBQUNBLHlDQUF5QywwREFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFEQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBdUM7QUFDbEUsb0JBQW9CLHFDQUFxQztBQUN6RDtBQUNBLGdCQUFnQixzRUFBd0M7QUFDeEQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQXFDO0FBQ3JFLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQSxnQkFBZ0Isb0VBQXNDO0FBQ3RELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaURBQXVDO0FBQ3hEO0FBQ0EsNEJBQTRCLHNFQUF3QztBQUNwRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCLGlEQUFxQztBQUN0RDtBQUNBLDRCQUE0QixvRUFBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3Q0FBd0Msb0VBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFrQjtBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEZBQWlDO0FBQ2xFO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixRQUFRLE9BQU87QUFDZixRQUFRLE9BQU87QUFDZixRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxxREFBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvZXNtL2FsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLTc2ZDE1MmU3LmpzP2RmYWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXyBhcyBfX2F3YWl0ZXIsIGYgYXMgZnJvbUhleCwgdCBhcyB0b0hleCwgbiBhcyBub29wLCBDIGFzIEN1c3RvbU5ldHdvcmtzLCBpIGFzIGlzQWxjaGVteUV2ZW50LCB2IGFzIHZlcmlmeUFsY2hlbXlFdmVudE5hbWUsIGMgYXMgRXRoZXJzRXZlbnQsIGUgYXMgZ2V0QWxjaGVteUV2ZW50VGFnLCBEIGFzIERFRkFVTFRfQUxDSEVNWV9BUElfS0VZLCBBIGFzIEFMQ0hFTVlfRVZFTlRfVFlQRVMsIGggYXMgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFLCBqIGFzIEFsY2hlbXlTdWJzY3JpcHRpb24sIGsgYXMgQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSwgViBhcyBWRVJTSU9OLCBFIGFzIEV0aGVyc05ldHdvcmsgfSBmcm9tICcuL2luZGV4LWJiODRhNDMzLmpzJztcbmltcG9ydCBTdHVyZHlXZWJTb2NrZXQgZnJvbSAnc3R1cmR5LXdlYnNvY2tldCc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJztcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcbmltcG9ydCB7IEFsY2hlbXlQcm92aWRlciB9IGZyb20gJy4vYWxjaGVteS1wcm92aWRlci1jMTM4MjdhZi5qcyc7XG5pbXBvcnQgJy4vYXBpL3V0aWxzJztcbmltcG9ydCAnYXhpb3MnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcic7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L3dhbGxldCc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L3dlYic7XG5cbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYmxvY2tzIHRvIGJhY2tmaWxsLiBJZiBtb3JlIHRoYW4gdGhpcyBtYW55IGJsb2NrcyBoYXZlXHJcbiAqIGJlZW4gbWlzc2VkLCB0aGVuIHdlJ2xsIHNhZGx5IG1pc3MgZGF0YSwgYnV0IHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGRvbid0XHJcbiAqIGVuZCB1cCByZXF1ZXN0aW5nIHRob3VzYW5kcyBvZiBibG9ja3MgaWYgc29tZWJvZHkgbGVmdCB0aGVpciBsYXB0b3AgY2xvc2VkIGZvciBhIHdlZWsuXHJcbiAqL1xyXG5jb25zdCBNQVhfQkFDS0ZJTExfQkxPQ0tTID0gMTIwO1xyXG4vKipcclxuICogVGhlIFdlYnNvY2tldEJhY2tmaWxsZXIgZmV0Y2hlcyBldmVudHMgdGhhdCB3ZXJlIHNlbnQgc2luY2UgYSBwcm92aWRlZCBibG9ja1xyXG4gKiBudW1iZXIuIFRoaXMgaXMgdXNlZCBpbiB0aGUge0BsaW5rIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcn0gdG8gYmFja2ZpbGxcclxuICogZXZlbnRzIHRoYXQgd2VyZSB0cmFuc21pdHRlZCB3aGlsZSB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRvd24uXHJcbiAqXHJcbiAqIFRoZSBiYWNrZmlsbGVyIGJhY2tmaWxscyB0d28gbWFpbiBldGhfc3Vic2NyaWJlIGV2ZW50czogYGxvZ3NgIGFuZCBgbmV3SGVhZHNgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFdlYnNvY2tldEJhY2tmaWxsZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgLy8gVE9ETzogVXNlIEhUVFAgcHJvdmlkZXIgdG8gZG8gYmFja2ZpbGwuXHJcbiAgICAgICAgdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyA9IE1BWF9CQUNLRklMTF9CTE9DS1M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYmFja2ZpbGwgZm9yIGBuZXdIZWFkc2AgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZCBXaGV0aGVyIHRoZSBiYWNrZmlsbCByZXF1ZXN0IGlzIGNhbmNlbGxlZC5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0hlYWRzIFByZXZpb3VzIGhlYWQgcmVxdWVzdHMgdGhhdCB3ZXJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbUJsb2NrTnVtYmVyIFRoZSBibG9jayBudW1iZXIgdG8gc3RhcnQgYmFja2ZpbGxpbmcgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiBgbmV3SGVhZHNgIGV2ZW50cyB0aGF0IHdlcmUgc2VudCBzaW5jZSB0aGUgbGFzdCBiYWNrZmlsbC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV3SGVhZHNCYWNrZmlsbChpc0NhbmNlbGxlZCwgcHJldmlvdXNIZWFkcywgZnJvbUJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcHJldmlvdXMgaGVhZHMgdG8gZmV0Y2gsIHJldHVybiBuZXcgaGVhZHMgc2luY2VcclxuICAgICAgICAgICAgLy8gYGZyb21CbG9ja051bWJlcmAsIG9yIHVwIHRvIG1heEJhY2tmaWxsQmxvY2tzIGZyb20gdGhlIGN1cnJlbnQgaGVhZC5cclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzSGVhZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBlbWl0dGVkIGV2ZW50IGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW9yZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYCB3b3J0aCBvZlxyXG4gICAgICAgICAgICAvLyBuZXcgaGVhZHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWVuQmxvY2tOdW1iZXIgPSBmcm9tSGV4KHByZXZpb3VzSGVhZHNbcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxXS5udW1iZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtaW5CbG9ja051bWJlciA9IHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzICsgMTtcclxuICAgICAgICAgICAgaWYgKGxhc3RTZWVuQmxvY2tOdW1iZXIgPD0gbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKG1pbkJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVG8gY2FwdHVyZSBhbGwgYG5ld0hlYWRzYCBldmVudHMsIHJldHVybiBhbGwgaGVhZCBldmVudHMgZnJvbSB0aGUgbGFzdFxyXG4gICAgICAgICAgICAvLyBzZWVuIGJsb2NrIG51bWJlciB0byBjdXJyZW50ICsgYW55IG9mIHRoZSBwcmV2aW91cyBoZWFkcyB0aGF0IHdlcmUgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlb3JnSGVhZHMgPSB5aWVsZCB0aGlzLmdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSGVhZHMgPSB5aWVsZCB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKGxhc3RTZWVuQmxvY2tOdW1iZXIgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlb3JnSGVhZHMsIC4uLmludGVybWVkaWF0ZUhlYWRzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBiYWNrZmlsbCBmb3IgYGxvZ3NgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWQgV2hldGhlciB0aGUgYmFja2ZpbGwgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSBmaWx0ZXIgb2JqZWN0IHRoYXQgYWNjb21wYW5pZXMgYSBsb2dzIHN1YnNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0xvZ3MgUHJldmlvdXMgbG9nIHJlcXVlc3RzIHRoYXQgd2VyZSBzZW50LlxyXG4gICAgICogQHBhcmFtIGZyb21CbG9ja051bWJlciBUaGUgYmxvY2sgbnVtYmVyIHRvIHN0YXJ0IGJhY2tmaWxsaW5nIGZyb20uXHJcbiAgICAgKi9cclxuICAgIGdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBwcmV2aW91c0xvZ3MsIGZyb21CbG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHByZXZpb3VzIGxvZ3MgdG8gZmV0Y2gsIHJldHVybiBuZXcgbG9ncyBzaW5jZVxyXG4gICAgICAgICAgICAvLyBgZnJvbUJsb2NrTnVtYmVyYCwgb3IgdXAgdG8gYG1heEJhY2tmaWxsQmxvY2tzYCBmcm9tIHRoZSBjdXJyZW50IGhlYWQuXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xvZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIE1hdGgubWF4KGZyb21CbG9ja051bWJlciwgdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MpICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IGVtaXR0ZWQgbG9nIGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW1vdmVkIGxvZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYFxyXG4gICAgICAgICAgICAvLyB3b3J0aCBvZiBsb2dzLlxyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VlbkJsb2NrTnVtYmVyID0gZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQmxvY2tOdW1iZXIgPSB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDwgbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgbWluQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxsIGxvZyBldmVudHMgdGhhdCBoYXZlIGhhcHBlbmVkIGFsb25nIHdpdGggbG9nIGV2ZW50cyB0aGF0IGhhdmVcclxuICAgICAgICAgICAgLy8gYmVlbiByZW1vdmVkIGR1ZSB0byBhIGNoYWluIHJlb3JnLlxyXG4gICAgICAgICAgICBjb25zdCBjb21tb25BbmNlc3RvciA9IHlpZWxkIHRoaXMuZ2V0Q29tbW9uQW5jZXN0b3IoaXNDYW5jZWxsZWQsIHByZXZpb3VzTG9ncyk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBBbGwgcHJldmlvdXMgbG9ncyB3aXRoIGEgYmxvY2sgbnVtYmVyIGdyZWF0ZXIgdGhhbiB0aGUgY29tbW9uIGFuY2VzdG9yXHJcbiAgICAgICAgICAgIC8vIHdlcmUgcGFydCBvZiBhIHJlLW9yZywgc28gbWFyayB0aGVtIGFzIHN1Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRMb2dzID0gcHJldmlvdXNMb2dzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGxvZyA9PiBmcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcilcclxuICAgICAgICAgICAgICAgIC5tYXAobG9nID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZyksIHsgcmVtb3ZlZDogdHJ1ZSB9KSkpO1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLCBzdGFydCBiYWNrZmlsbCBmcm9tIHRoZSBvbGRlc3QgbG9nJ3NcclxuICAgICAgICAgICAgLy8gYmxvY2sgbnVtYmVyLlxyXG4gICAgICAgICAgICBjb25zdCBmcm9tQmxvY2tJbmNsdXNpdmUgPSBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICAgICAgICAgICAgICA/IGZyb21IZXgocHJldmlvdXNMb2dzWzBdLmJsb2NrTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgOiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcjtcclxuICAgICAgICAgICAgbGV0IGFkZGVkTG9ncyA9IHlpZWxkIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgLy8gRGUtZHVwZSBhbnkgbG9ncyB0aGF0IHdlcmUgYWxyZWFkeSBlbWl0dGVkLlxyXG4gICAgICAgICAgICBhZGRlZExvZ3MgPSBhZGRlZExvZ3MuZmlsdGVyKGxvZyA9PiBsb2cgJiZcclxuICAgICAgICAgICAgICAgIChmcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21IZXgobG9nLmxvZ0luZGV4KSA+IGNvbW1vbkFuY2VzdG9yLmxvZ0luZGV4KSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlbW92ZWRMb2dzLCAuLi5hZGRlZExvZ3NdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgbmV3IG1heCBiYWNrZmlsbCBibG9ja3MuIFZJU0lCTEUgT05MWSBGT1IgVEVTVElORy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2V0TWF4QmFja2ZpbGxCbG9jayhuZXdNYXgpIHtcclxuICAgICAgICB0aGlzLm1heEJhY2tmaWxsQmxvY2tzID0gbmV3TWF4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGJsb2NrIG51bWJlciBhcyBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlckhleCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2Jsb2NrTnVtYmVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KGJsb2NrTnVtYmVySGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYG5ld0hlYWRgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWRcclxuICAgICAqIGhlYWRzIGRvIG5vdCBpbmNsdWRlIHJlLW9yZ2VkIGhlYWRzLiBVc2Uge0BsaW5rIGdldFJlb3JnSGVhZHN9IHRvIGZpbmQgaGVhZHNcclxuICAgICAqIHRoYXQgd2VyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEhlYWRFdmVudHNJblJhbmdlKGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CbG9ja0luY2x1c2l2ZTsgaSA8IHRvQmxvY2tFeGNsdXNpdmU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hQYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbdG9IZXgoaSksIGZhbHNlXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yc1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja0hlYWRzID0geWllbGQgdGhpcy5wcm92aWRlci5zZW5kQmF0Y2goYmF0Y2hQYXJ0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9ja0hlYWRzLm1hcCh0b05ld0hlYWRzRXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBoZWFkcyB0aGF0IHdlcmUgcGFydCBvZiBhIHJlb3JnIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBmcm9tIHRoZSBtb3N0IHJlY2VudCBoZWFkIGJhY2t3YXJkcyBpbiBvcmRlciB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBibG9jayB0aGF0IHdhcyBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkRXZlbnQgPSBwcmV2aW91c0hlYWRzW2ldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGZyb21IZXgob2xkRXZlbnQubnVtYmVyKSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoYXNoZXMgbWF0Y2gsIHRoZW4gY3VycmVudCBoZWFkIGluIHRoZSBpdGVyYXRpb24gd2FzIG5vdCByZS1vcmdlZC5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudC5oYXNoID09PSBibG9ja0hlYWQuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9OZXdIZWFkc0V2ZW50KGJsb2NrSGVhZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGUgd3JhcHBlciBhcm91bmQgYGV0aF9nZXRCbG9ja0J5TnVtYmVyYCB0aGF0IHJldHVybnMgdGhlIGNvbXBsZXRlXHJcbiAgICAgKiBibG9jayBpbmZvcm1hdGlvbiBmb3IgdGhlIHByb3ZpZGVkIGJsb2NrIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja0J5TnVtYmVyKGJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBbXHJcbiAgICAgICAgICAgICAgICB0b0hleChibG9ja051bWJlciksXHJcbiAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIHByZXZpb3VzIGxvZyBldmVudHMsIGZpbmRzIHRoZSBjb21tb24gYmxvY2sgbnVtYmVyIGZyb20gdGhlXHJcbiAgICAgKiBsb2dzIHRoYXQgbWF0Y2hlcyB0aGUgYmxvY2sgaGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHdoaWNoIGxvZ3MgYXJlIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyAxIGxlc3MgdGhhbiB0aGUgb2xkZXN0IGxvZydzIGJsb2NrIG51bWJlciBpZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldENvbW1vbkFuY2VzdG9yKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0xvZ3MpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGZyb20gdGhlIG1vc3QgcmVjZW50IGhlYWQgYmFja3dhcmRzIGluIG9yZGVyIHRvIGZpbmQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIC8vIGJsb2NrIHRoYXQgd2FzIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgICAgICAgIGxldCBibG9ja0hlYWQgPSB5aWVsZCB0aGlzLmdldEJsb2NrQnlOdW1iZXIoZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldmlvdXNMb2dzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRMb2cgPSBwcmV2aW91c0xvZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB1cGRhdGVkIGJsb2NrcyBhcmUgZmV0Y2hlZCBldmVyeSB0aW1lIHRoZSBsb2cncyBibG9jayBudW1iZXJcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkTG9nLmJsb2NrTnVtYmVyICE9PSBibG9ja0hlYWQubnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGZyb21IZXgob2xkTG9nLmJsb2NrTnVtYmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBsb2dzIGFyZSBvcmRlcmVkIGluIGFzY2VuZGluZyBvcmRlciwgdGhlIGZpcnN0IGxvZyB0aGF0IG1hdGNoZXNcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBoYXNoIHNob3VsZCBiZSB0aGUgbGFyZ2VzdCBsb2dJbmRleC5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRMb2cuYmxvY2tIYXNoID09PSBibG9ja0hlYWQuaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBmcm9tSGV4KG9sZExvZy5ibG9ja051bWJlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0luZGV4OiBmcm9tSGV4KG9sZExvZy5sb2dJbmRleClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxyXG4gICAgICAgICAgICAgICAgbG9nSW5kZXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBgbG9nc2AgZXZlbnRzIGluIHRoZSBwcm92aWRlZCByYW5nZS4gTm90ZSB0aGF0IHRoZSByZXR1cm5lZCBsb2dzXHJcbiAgICAgKiBkbyBub3QgaW5jbHVkZSByZW1vdmVkIGxvZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqLyBnZXRMb2dzSW5SYW5nZShmaWx0ZXIsIGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlRmlsdGVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWx0ZXIpLCB7IGZyb21CbG9jazogdG9IZXgoZnJvbUJsb2NrSW5jbHVzaXZlKSwgdG9CbG9jazogdG9IZXgodG9CbG9ja0V4Y2x1c2l2ZSAtIDEpIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKCdldGhfZ2V0TG9ncycsIFtyYW5nZUZpbHRlcl0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRvTmV3SGVhZHNFdmVudChoZWFkKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkKTtcclxuICAgIGRlbGV0ZSByZXN1bHQudG90YWxEaWZmaWN1bHR5O1xyXG4gICAgZGVsZXRlIHJlc3VsdC50cmFuc2FjdGlvbnM7XHJcbiAgICBkZWxldGUgcmVzdWx0LnVuY2xlcztcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlTmV3SGVhZHMoZXZlbnRzKSB7XHJcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZXZlbnQgPT4gZXZlbnQuaGFzaCk7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlTG9ncyhldmVudHMpIHtcclxuICAgIHJldHVybiBkZWR1cGUoZXZlbnRzLCBldmVudCA9PiBgJHtldmVudC5ibG9ja0hhc2h9LyR7ZXZlbnQubG9nSW5kZXh9YCk7XHJcbn1cclxuZnVuY3Rpb24gZGVkdXBlKGl0ZW1zLCBnZXRLZXkpIHtcclxuICAgIGNvbnN0IGtleXNTZWVuID0gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGdldEtleShpdGVtKTtcclxuICAgICAgICBpZiAoIWtleXNTZWVuLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGtleXNTZWVuLmFkZChrZXkpO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuY29uc3QgQ0FOQ0VMTEVEID0gbmV3IEVycm9yKCdDYW5jZWxsZWQnKTtcclxuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCkge1xyXG4gICAgaWYgKGlzQ2FuY2VsbGVkKCkpIHtcclxuICAgICAgICB0aHJvdyBDQU5DRUxMRUQ7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgSEVBUlRCRUFUX0lOVEVSVkFMID0gMzAwMDA7XHJcbmNvbnN0IEhFQVJUQkVBVF9XQUlUX1RJTUUgPSAxMDAwMDtcclxuY29uc3QgQkFDS0ZJTExfVElNRU9VVCA9IDYwMDAwO1xyXG5jb25zdCBCQUNLRklMTF9SRVRSSUVTID0gNTtcclxuLyoqXHJcbiAqIFN1YnNjcmlwdGlvbnMgaGF2ZSBhIG1lbW9yeSBvZiByZWNlbnQgZXZlbnRzIHRoZXkgaGF2ZSBzZW50IHNvIHRoYXQgaW4gdGhlXHJcbiAqIGV2ZW50IHRoYXQgdGhleSBkaXNjb25uZWN0IGFuZCBuZWVkIHRvIGJhY2tmaWxsLCB0aGV5IGNhbiBkZXRlY3QgcmUtb3Jncy5cclxuICogS2VlcCBhIGJ1ZmZlciB0aGF0IGdvZXMgYmFjayBhdCBsZWFzdCB0aGVzZSBtYW55IGJsb2NrcywgdGhlIG1heGltdW0gYW1vdW50XHJcbiAqIGF0IHdoaWNoIHdlIG1pZ2h0IGNvbmNlaXZhYmx5IHNlZSBhIHJlLW9yZy5cclxuICpcclxuICogTm90ZSB0aGF0IHdoaWxlIG91ciBidWZmZXIgZ29lcyBiYWNrIHRoaXMgbWFueSBibG9ja3MsIGl0IG1heSBjb250YWluIG1vcmVcclxuICogdGhhbiB0aGlzIG1hbnkgZWxlbWVudHMsIHNpbmNlIGluIHRoZSBjYXNlIG9mIGxvZ3Mgc3Vic2NyaXB0aW9ucyBtb3JlIHRoYW5cclxuICogb25lIGV2ZW50IG1heSBiZSBlbWl0dGVkIGZvciBhIGJsb2NrLlxyXG4gKi9cclxuY29uc3QgUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQgPSAxMDtcclxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBmbyB0aGUgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlXZWJTb2NrZXRQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIFdlYlNvY2tldFByb3ZpZGVyIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgd3NDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvKGFsY2hlbXlOZXR3b3JrLCBhcGlLZXksICd3c3MnKTtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGBhbGNoZW15LXNkay0ke1ZFUlNJT059YDtcclxuICAgICAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIGNvbmZpZyBVUkwgb3ZlcnJpZGUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBjcmVhdGVkIG9uZS5cclxuICAgICAgICBjb25zdCB3cyA9IG5ldyBTdHVyZHlXZWJTb2NrZXQoKF9hID0gY29uZmlnLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29ubmVjdGlvbi51cmwsIHByb3RvY29sLCB7XHJcbiAgICAgICAgICAgIHdzQ29uc3RydWN0b3I6IHdzQ29uc3RydWN0b3IgIT09IG51bGwgJiYgd3NDb25zdHJ1Y3RvciAhPT0gdm9pZCAwID8gd3NDb25zdHJ1Y3RvciA6IGdldFdlYnNvY2tldENvbnN0cnVjdG9yKClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFsY2hlbXkgbmFtZWQgbmV0d29yayBpbnB1dCB0byB0aGUgbmV0d29yayBuYW1lcyB1c2VkIGJ5XHJcbiAgICAgICAgLy8gZXRoZXJzLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IHN1cGVyIGNvbnN0cnVjdG9yIGluIEpzb25ScGNQcm92aWRlciB0b1xyXG4gICAgICAgIC8vIGNvcnJlY3RseSBzZXQgdGhlIG5ldHdvcmsuXHJcbiAgICAgICAgY29uc3QgZXRoZXJzTmV0d29yayA9IEV0aGVyc05ldHdvcmtbYWxjaGVteU5ldHdvcmtdO1xyXG4gICAgICAgIHN1cGVyKHdzLCBldGhlcnNOZXR3b3JrKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcclxuICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIFdlYlNvY2tldCByZWNvbm5lY3Rpb24sIGFsbCBzdWJzY3JpcHRpb25zIGFyZSBsb3N0IGFuZCB3ZVxyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb25lcyB0byByZXBsYWNlIHRoZW0sIGJ1dCB3ZSB3YW50IHRvIGNyZWF0ZSB0aGUgaWxsdXNpb24gdGhhdFxyXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBzdWJzY3JpcHRpb25zIHBlcnNpc3QuIFRodXMsIG1haW50YWluIGEgbWFwcGluZyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIFwidmlydHVhbFwiIHN1YnNjcmlwdGlvbiBpZHMgd2hpY2ggYXJlIHZpc2libGUgdG8gdGhlIGNvbnN1bWVyIHRvIHRoZVxyXG4gICAgICAgIC8vIFwicGh5c2ljYWxcIiBzdWJzY3JpcHRpb24gaWRzIG9mIHRoZSBhY3R1YWwgY29ubmVjdGlvbnMuIFRoaXMgdGVybWlub2xvZ3kgaXNcclxuICAgICAgICAvLyBib3Jyb3dlZCBmcm9tIHZpcnR1YWwgYW5kIHBoeXNpY2FsIG1lbW9yeSwgd2hpY2ggaGFzIGEgc2ltaWxhciBtYXBwaW5nLlxyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGV0aGVycyB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9IGFscmVhZHkgaGFuZGxlcyBhbmQgZW1pdHNcclxuICAgICAgICAgKiBtZXNzYWdlcy4gVG8gYWxsb3cgYmFja2ZpbGxpbmcsIHRyYWNrIGFsbCBtZXNzYWdlcyB0aGF0IGFyZSBlbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICghaXNTdWJzY3JpcHRpb25FdmVudChtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBoeXNpY2FsSWQgPSBtZXNzYWdlLnBhcmFtcy5zdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxJZCA9IHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5nZXQocGh5c2ljYWxJZCk7XHJcbiAgICAgICAgICAgIGlmICghdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ubWV0aG9kICE9PSAnZXRoX3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5wYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld0hlYWRzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRzU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRzTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc0JhY2tmaWxsaW5nLCBiYWNrZmlsbEJ1ZmZlciB9ID0gbmV3SGVhZHNTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IG5ld0hlYWRzTWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFja2ZpbGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlcihiYWNrZmlsbEJ1ZmZlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGh5c2ljYWxJZCAhPT0gdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgcmUtb3BlbmVkIHN1YnNjcmlwdGlvbiwgZXRoZXJzIHdpbGwgbm90IGVtaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50LCBzbyB0aGUgU0RLIGhhcyB0by5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdGhlcnMgc3Vic2NyaXB0aW9uIG1hcHBpbmcgd2lsbCBlbWl0IHRoZSBldmVudCwganVzdCBzdG9yZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb2dzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3NTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nc01lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNCYWNrZmlsbGluZywgYmFja2ZpbGxCdWZmZXIgfSA9IGxvZ3NTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGxvZ3NNZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrZmlsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0xvZ3NFdmVudHNCdWZmZXIoYmFja2ZpbGxCdWZmZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZpcnR1YWxJZCAhPT0gcGh5c2ljYWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBoeXNpY2FsSWQgIT09IHZpcnR1YWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIHJlLW9wZW5lZCBzdWJzY3JpcHRpb24sIGV0aGVycyB3aWxsIG5vdCBlbWl0IHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVudCwgc28gdGhlIFNESyBoYXMgdG8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSBtZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQodmlydHVhbElkLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gcmVvcGVuczpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDEuIFJlc3Vic2NyaWJlIHRvIGFsbCBleGlzdGluZyBzdWJzY3JpcHRpb25zIGFuZCBzdGFydCBiYWNrZmlsbGluZ1xyXG4gICAgICAgICAqIDIuIFJlc3RhcnQgaGVhcnQgYmVhdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYW5kbGVSZW9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5jbGVhcigpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNhbmNlbCwgaXNDYW5jZWxsZWQgfSA9IG1ha2VDYW5jZWxUb2tlbigpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsID0gY2FuY2VsO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgYmFja2ZpbGxpbmcgXCIke3N1YnNjcmlwdGlvbi5wYXJhbXNbMF19XCIgc3Vic2NyaXB0aW9uLiBTb21lIGV2ZW50cyBtYXkgYmUgbWlzc2luZy5gLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIHRoZSBoZWFydGJlYXQgYW5kIGFueSBwZW5kaW5nIGJhY2tmaWxscyBiZWluZyBwZXJmb3JtZWQuIFRoaXMgaXNcclxuICAgICAgICAgKiBjYWxsZWQgd2hlbiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gZ29lcyBkb3duIG9yIGlzIGRpc2Nvbm5lY3RlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xyXG4gICAgICAgIC8vIFN0YXJ0IGhlYXJ0YmVhdCBhbmQgYmFja2ZpbGxlciBmb3IgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxyXG4gICAgICAgIHRoaXMuYmFja2ZpbGxlciA9IG5ldyBXZWJzb2NrZXRCYWNrZmlsbGVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWRkU29ja2V0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwgPSBub29wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBCYXNlUHJvdmlkZXIuZ2V0TmV0d29ya2AgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG92ZXJyaWRlIGFsbG93cyB0aGUgU0RLIHRvIHNldCB0aGUgcHJvdmlkZXIncyBuZXR3b3JrIHRvIHZhbHVlcyBub3RcclxuICAgICAqIHlldCBzdXBwb3J0ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmcnICYmIG5ldHdvcmsgaW4gQ3VzdG9tTmV0d29ya3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbU5ldHdvcmtzW25ldHdvcmtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHRoZSBzdGFuZGFyZCBldGhlcnMuanMgZ2V0TmV0d29yayBtZXRob2QgZm9yIG90aGVyIG5ldHdvcmtzLlxyXG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycyB0aGF0IGluY2x1ZGVzIEFsY2hlbXkgYmFzZWQgc3Vic2NyaXB0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBPdmVycmlkZSBgTGlzdGVuZXJgIHR5cGUgdG8gZ2V0IHR5cGUgYXV0b2NvbXBsZXRpb25zLlxyXG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMgdGhhdCBpbmNsdWRlcyBBbGNoZW15IGJhc2VkXHJcbiAgICAgKiBzdWJzY3JpcHRpb25zLiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIHRyaWdnZXJlZCBmb3Igb25seSB0aGUgbmV4dFxyXG4gICAgICoge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQsIGFmdGVyIHdoaWNoIGl0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBPdmVycmlkZSBgTGlzdGVuZXJgIHR5cGUgdG8gZ2V0IHR5cGUgYXV0b2NvbXBsZXRpb25zLlxyXG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBsaXN0ZW5lcn0gZm9yIHRoZSB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm9cclxuICAgICAqIGxpc3RlbmVyIGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gdW5saXN0ZW4gdG8uXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZS5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmIChpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm8gZXZlbnRcclxuICAgICAqIGlzIHByb3ZpZGVkLCBhbGwgZXZlbnRzIGFuZCB0aGVpciBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgdGhlIHRvdGFsIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBgQmFzZVByb3ZpZGVyYCBpbiBvcmRlciB0byBwcm9wZXJseSBmb3JtYXQgdGhlXHJcbiAgICAgKiBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xyXG4gICAgICAgIGlmIChpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZlcmlmeUFsY2hlbXlFdmVudE5hbWUoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXRoZXJzRXZlbnQoZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBfc3RhcnRFdmVudCgpYCBtZXRob2QgaW4gZXRoZXJzLmpzJ3NcclxuICAgICAqIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn0gdG8gaW5jbHVkZSBhZGRpdGlvbmFsIGFsY2hlbXkgbWV0aG9kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IHR5cGUgaXMgYSBjdXN0b20gQWxjaGVteSBzdWJzY3JpcHRpb24uXHJcbiAgICAgICAgY29uc3QgY3VzdG9tTG9naWNUeXBlcyA9IFsuLi5BTENIRU1ZX0VWRU5UX1RZUEVTLCAnYmxvY2snLCAnZmlsdGVyJ107XHJcbiAgICAgICAgaWYgKGN1c3RvbUxvZ2ljVHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21TdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1cGVyLl9zdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gZnJvbSBldGhlcnMuanMncyB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9XHJcbiAgICAgKlxyXG4gICAgICogTW9kaWZpZWQgaW4gb3JkZXIgdG8gYWRkIG1hcHBpbmdzIGZvciBiYWNrZmlsbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBfc3Vic2NyaWJlKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jLCBldmVudCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBpZiAoc3ViSWRQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKHBhcmFtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKCdldGhfc3Vic2NyaWJlJywgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJJZHNbdGFnXSA9IHN1YklkUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhcmFtcyA9IHlpZWxkIFByb21pc2UuYWxsKHBhcmFtKTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuc2V0KHN1YklkLCB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc3Vic2NyaWJlJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogcmVzb2x2ZWRQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBzdGFydGluZ0Jsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgdmlydHVhbElkOiBzdWJJZCxcclxuICAgICAgICAgICAgICAgIHBoeXNpY2FsSWQ6IHN1YklkLFxyXG4gICAgICAgICAgICAgICAgc2VudEV2ZW50czogW10sXHJcbiAgICAgICAgICAgICAgICBpc0JhY2tmaWxsaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyOiBbXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChzdWJJZCwgc3ViSWQpO1xyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnLCBwcm9jZXNzRnVuYyB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbGluZSBpcyB0aGUgb25seSBtb2RpZmllZCBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHNlbmRCYXRjaChwYXJ0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0SWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFydHMubWFwKCh7IG1ldGhvZCwgcGFyYW1zIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcclxuICAgICAgICAgICAgICAgICAgICBpZDogYGFsY2hlbXktc2RrOiR7bmV4dElkKyt9YFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRCYXRjaENvbmN1cnJlbnRseShwYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCgpO1xyXG4gICAgICAgIHJldHVybiBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgZXRoZXIncyBgaXNDb21tdW5pdHlSZXNvdXJjZSgpYCBtZXRob2QuIFJldHVybnMgdHJ1ZSBpZiB0aGVcclxuICAgICAqIGN1cnJlbnQgYXBpIGtleSBpcyB0aGUgZGVmYXVsdCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpS2V5ID09PSBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgV2ViU29ja2V0UHJvdmlkZXIuX3N0b3BFdmVudCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBzdXBwb3J0IEFsY2hlbXknc1xyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGUgYnkgYWxsb3dpbmcgdGhlIHByb3ZpZGVyIHRvIHByb3Blcmx5IHN0b3AgQWxjaGVteSdzXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IHRhZyA9IGV2ZW50LnRhZztcclxuICAgICAgICAvLyBTVEFSVCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgaWYgKEFMQ0hFTVlfRVZFTlRfVFlQRVMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBwZW5kaW5nIHRyYW5zYWN0aW9uIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5maWx0ZXIoZSA9PiBBTENIRU1ZX0VWRU5UX1RZUEVTLmluY2x1ZGVzKGUudHlwZSkpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICd0eCcpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyB0cmFuc2FjdGlvbiBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5maWx0ZXIoZSA9PiBlLnR5cGUgPT09ICd0eCcpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhZyA9ICd0eCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdWJJZCA9IHRoaXMuX3N1Yklkc1t0YWddO1xyXG4gICAgICAgIGlmICghc3ViSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgdm9pZCBzdWJJZC50aGVuKHN1YklkID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdWJzW3N1YklkXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzW3N1YklkXTtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmQoJ2V0aF91bnN1YnNjcmliZScsIFtzdWJJZF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgYWRkU29ja2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcigncmVvcGVuJywgdGhpcy5oYW5kbGVSZW9wZW4pO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdkb3duJywgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlKTtcclxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVvcGVuJywgdGhpcy5oYW5kbGVSZW9wZW4pO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkb3duJywgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW9wZW5zIHRoZSBiYWNrZmlsbCBiYXNlZCBvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZFxyXG4gICAgICogQHBhcmFtIHN1YnNjcmlwdGlvblxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHJlc3Vic2NyaWJlQW5kQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdmlydHVhbElkLCBtZXRob2QsIHBhcmFtcywgc2VudEV2ZW50cywgYmFja2ZpbGxCdWZmZXIsIHN0YXJ0aW5nQmxvY2tOdW1iZXIgfSA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQmFja2ZpbGxpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBiYWNrZmlsbEJ1ZmZlci5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGh5c2ljYWxJZCA9IHlpZWxkIHRoaXMuc2VuZChtZXRob2QsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5waHlzaWNhbElkID0gcGh5c2ljYWxJZDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5zZXQocGh5c2ljYWxJZCwgdmlydHVhbElkKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1zWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmV3SGVhZHMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tmaWxsRXZlbnRzID0geWllbGQgd2l0aEJhY2tvZmZSZXRyaWVzKCgpID0+IHdpdGhUaW1lb3V0KHRoaXMuYmFja2ZpbGxlci5nZXROZXdIZWFkc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCksIEJBQ0tGSUxMX1JFVFJJRVMsICgpID0+ICFpc0NhbmNlbGxlZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGRlZHVwZU5ld0hlYWRzKFsuLi5iYWNrZmlsbEV2ZW50cywgLi4uYmFja2ZpbGxCdWZmZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbWl0TmV3SGVhZHNFdmVudCh2aXJ0dWFsSWQsIGV2ZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsb2dzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBwYXJhbXNbMV0gfHwge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tmaWxsRXZlbnRzID0geWllbGQgd2l0aEJhY2tvZmZSZXRyaWVzKCgpID0+IHdpdGhUaW1lb3V0KHRoaXMuYmFja2ZpbGxlci5nZXRMb2dzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIGZpbHRlciwgc2VudEV2ZW50cywgc3RhcnRpbmdCbG9ja051bWJlciksIEJBQ0tGSUxMX1RJTUVPVVQpLCBCQUNLRklMTF9SRVRSSUVTLCAoKSA9PiAhaXNDYW5jZWxsZWQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBkZWR1cGVMb2dzKFsuLi5iYWNrZmlsbEV2ZW50cywgLi4uYmFja2ZpbGxCdWZmZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbWl0TG9nc0V2ZW50KHZpcnR1YWxJZCwgZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmlzQmFja2ZpbGxpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXROZXdIZWFkc0V2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0TG9nc0V2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW1pdHMgYW4gZXZlbnQgdG8gY29uc3VtZXJzLCBidXQgYWxzbyByZW1lbWJlcnMgaXQgaW4gaXRzIHN1YnNjcmlwdGlvbnMnc1xyXG4gICAgICogYHNlbnRFdmVudHNgIGJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBkZXRlY3QgcmUtb3JncyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wc1xyXG4gICAgICogYW5kIG5lZWRzIHRvIGJlIHJlY29ubmVjdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBlbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpIHtcclxuICAgICAgICB0aGlzLnJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKTtcclxuICAgICAgICB0aGlzLmVtaXRFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBlbWl0RXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcclxuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdEdlbmVyaWNFdmVudChzdWJzY3JpcHRpb24sIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2ViMyBtb2RpZmllcyB0aGVzZSBldmVudCBvYmplY3RzIG9uY2Ugd2UgcGFzcyB0aGVtIG9uIChjaGFuZ2luZyBoZXhcclxuICAgICAgICAvLyBudW1iZXJzIHRvIG51bWJlcnMpLiBXZSB3YW50IHRoZSBvcmlnaW5hbCBldmVudCwgc28gbWFrZSBhIGRlZmVuc2l2ZVxyXG4gICAgICAgIC8vIGNvcHkuXHJcbiAgICAgICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHN1YnNjcmlwdGlvbi5zZW50RXZlbnRzLCBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCBnZXRCbG9ja051bWJlcik7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0R2VuZXJpY0V2ZW50KHN1YnNjcmlwdGlvbiwgcmVzdWx0KSB7XHJcbiAgICAgICAgY29uc3QgZW1pdEZ1bmN0aW9uID0gdGhpcy5lbWl0UHJvY2Vzc0ZuKHN1YnNjcmlwdGlvbi5ldmVudCk7XHJcbiAgICAgICAgZW1pdEZ1bmN0aW9uKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGhlYXJ0YmVhdCB0aGF0IHBpbmdzIHRoZSB3ZWJzb2NrZXQgc2VydmVyIHBlcmlvZGljYWxseSB0byBlbnN1cmVcclxuICAgICAqIHRoYXQgdGhlIGNvbm5lY3Rpb24gc3RheXMgb3Blbi5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhcnRIZWFydGJlYXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgd2l0aFRpbWVvdXQodGhpcy5zZW5kKCduZXRfdmVyc2lvbicpLCBIRUFSVEJFQVRfV0FJVF9USU1FKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZWNvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLCBIRUFSVEJFQVRfSU5URVJWQUwpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBzZW5kcyB0aGUgYmF0Y2ggY29uY3VycmVudGx5IGFzIGluZGl2aWR1YWwgcmVxdWVzdHMgcmF0aGVyIHRoYW5cclxuICAgICAqIGFzIGEgYmF0Y2gsIHdoaWNoIHdhcyB0aGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24uIFRoZSBvcmlnaW5hbCBiYXRjaCBsb2dpY1xyXG4gICAgICogaXMgcHJlc2VydmVkIGluIHRoaXMgaW1wbGVtZW50YXRpb24gaW4gb3JkZXIgZm9yIGZhc3RlciBwb3J0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXlsb2FkXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETyhjbGVhbnVwKTogUmVmYWN0b3IgYW5kIHJlbW92ZSB1c2FnZXMgb2YgYHNlbmRCYXRjaCgpYC5cclxuICAgIC8vIFRPRE8oZXJyb3JzKTogVXNlIGFsbFNldHRsZWQoKSBvbmNlIHdlIGhhdmUgbW9yZSBlcnJvciBoYW5kbGluZy5cclxuICAgIHNlbmRCYXRjaENvbmN1cnJlbnRseShwYXlsb2FkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHBheWxvYWQubWFwKHJlcSA9PiB0aGlzLnNlbmQocmVxLm1ldGhvZCwgcmVxLnBhcmFtcykpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGN1c3RvbVN0YXJ0RXZlbnQoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgaGFzaGVzT25seSB9ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1xyXG4gICAgICAgICAgICAgICAgQWxjaGVteVN1YnNjcmlwdGlvbi5QRU5ESU5HX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgIHsgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgaGFzaGVzT25seSB9XHJcbiAgICAgICAgICAgIF0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGFkZHJlc3NlcywgaW5jbHVkZVJlbW92ZWQsIGhhc2hlc09ubHkgfSA9IGV2ZW50O1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFtcclxuICAgICAgICAgICAgICAgIEFsY2hlbXlTdWJzY3JpcHRpb24uTUlORURfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgeyBhZGRyZXNzZXMsIGluY2x1ZGVSZW1vdmVkLCBoYXNoZXNPbmx5IH1cclxuICAgICAgICAgICAgXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnYmxvY2snKSB7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKCdibG9jaycsIFsnbmV3SGVhZHMnXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSAnZmlsdGVyJykge1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZShldmVudC50YWcsIFsnbG9ncycsIHRoaXMuX2dldEZpbHRlcihldmVudC5maWx0ZXIpXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRQcm9jZXNzRm4oZXZlbnQpIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHRoaXMuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBBbGNoZW15U3Vic2NyaXB0aW9uLlBFTkRJTkdfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21BZGRyZXNzOiBldmVudC5mcm9tQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICB0b0FkZHJlc3M6IGV2ZW50LnRvQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXNPbmx5OiBldmVudC5oYXNoZXNPbmx5XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICBjYXNlIEFMQ0hFTVlfTUlORURfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEU6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHRoaXMuZW1pdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBBbGNoZW15U3Vic2NyaXB0aW9uLk1JTkVEX1RSQU5TQUNUSU9OUyxcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IGV2ZW50LmFkZHJlc3NlcyxcclxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlUmVtb3ZlZDogZXZlbnQuaW5jbHVkZVJlbW92ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaGVzT25seTogZXZlbnQuaGFzaGVzT25seVxyXG4gICAgICAgICAgICAgICAgfSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgY2FzZSAnYmxvY2snOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBCaWdOdW1iZXIuZnJvbShyZXN1bHQubnVtYmVyKS50b051bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Jsb2NrJywgYmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAnZmlsdGVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVtb3ZlZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudC5maWx0ZXIsIHRoaXMuZm9ybWF0dGVyLmZpbHRlckxvZyhyZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXZlbnQgdHlwZSB0byBgZW1pdFByb2Nlc3NGbigpYCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLm9mZigpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xyXG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIubGlzdGVuZXJDb3VudCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC50YWcgPT09IGV2ZW50VGFnO1xyXG4gICAgICAgIH0pLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLmxpc3RlbmVycygpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLm1hcChldmVudCA9PiBldmVudC5saXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1xyXG4gICAgICAgICAgICAuZmlsdGVyKGV2ZW50ID0+IGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpXHJcbiAgICAgICAgICAgIC5tYXAoZXZlbnQgPT4gZXZlbnQubGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFdlYnNvY2tldENvbnN0cnVjdG9yKCkge1xyXG4gICAgcmV0dXJuIGlzTm9kZUVudmlyb25tZW50KCkgPyByZXF1aXJlKCd3ZWJzb2NrZXQnKS53M2N3ZWJzb2NrZXQgOiBXZWJTb2NrZXQ7XHJcbn1cclxuZnVuY3Rpb24gaXNOb2RlRW52aXJvbm1lbnQoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHByb2Nlc3MgIT0gbnVsbCAmJlxyXG4gICAgICAgIHByb2Nlc3MudmVyc2lvbnMgIT0gbnVsbCAmJlxyXG4gICAgICAgIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPSBudWxsKTtcclxufVxyXG4vLyBUT0RPKGNsZWFudXApOiBVc2UgY2xhc3MgdmFyaWFibGUgcmF0aGVyIHRoYW4gcGFzc2luZyBgaXNDYW5jZWxsZWRgIGV2ZXJ5d2hlcmUuXHJcbmZ1bmN0aW9uIG1ha2VDYW5jZWxUb2tlbigpIHtcclxuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcclxuICAgIHJldHVybiB7IGNhbmNlbDogKCkgPT4gKGNhbmNlbGxlZCA9IHRydWUpLCBpc0NhbmNlbGxlZDogKCkgPT4gY2FuY2VsbGVkIH07XHJcbn1cclxuLy8gVE9ETyhjbGVhbnVwKTogcmVwbGFjZSB3aXRoIFNESydzIGJhY2tvZmYgaW1wbGVtZW50YXRpb25cclxuY29uc3QgTUlOX1JFVFJZX0RFTEFZID0gMTAwMDtcclxuY29uc3QgUkVUUllfQkFDS09GRl9GQUNUT1IgPSAyO1xyXG5jb25zdCBNQVhfUkVUUllfREVMQVkgPSAzMDAwMDtcclxuZnVuY3Rpb24gd2l0aEJhY2tvZmZSZXRyaWVzKGYsIHJldHJ5Q291bnQsIHNob3VsZFJldHJ5ID0gKCkgPT4gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBsZXQgbmV4dFdhaXRUaW1lID0gMDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSByZXRyeUNvdW50IHx8ICFzaG91bGRSZXRyeShlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHlpZWxkIGRlbGF5KG5leHRXYWl0VGltZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dFdhaXRUaW1lID1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0V2FpdFRpbWUgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNSU5fUkVUUllfREVMQVlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihNQVhfUkVUUllfREVMQVksIFJFVFJZX0JBQ0tPRkZfRkFDVE9SICogbmV4dFdhaXRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGF5KG1zKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbn1cclxuZnVuY3Rpb24gd2l0aFRpbWVvdXQocHJvbWlzZSwgbXMpIHtcclxuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xyXG4gICAgICAgIHByb21pc2UsXHJcbiAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0JykpLCBtcykpXHJcbiAgICBdKTtcclxufVxyXG5mdW5jdGlvbiBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZnJvbUhleChldmVudC5udW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGdldExvZ3NCbG9ja051bWJlcihldmVudCkge1xyXG4gICAgcmV0dXJuIGZyb21IZXgoZXZlbnQuYmxvY2tOdW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUmVzcG9uc2UobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpIHx8XHJcbiAgICAgICAgKG1lc3NhZ2UuanNvbnJwYyA9PT0gJzIuMCcgJiYgbWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNTdWJzY3JpcHRpb25FdmVudChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gIWlzUmVzcG9uc2UobWVzc2FnZSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCkge1xyXG4gICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxufVxyXG5mdW5jdGlvbiBhZGRUb0xvZ3NFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQpIHtcclxuICAgIGFkZFRvUGFzdEV2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCwgZ2V0TG9nc0Jsb2NrTnVtYmVyKTtcclxufVxyXG4vKipcclxuICogQWRkcyBhIG5ldyBldmVudCB0byBhbiBhcnJheSBvZiBldmVudHMsIGV2aWN0aW5nIGFueSBldmVudHMgd2hpY2ggYXJlIHNvIG9sZFxyXG4gKiB0aGF0IHRoZXkgd2lsbCBubyBsb25nZXIgZmVhc2libHkgYmUgcGFydCBvZiBhIHJlb3JnLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gZ2V0QmxvY2tOdW1iZXIoZXZlbnQpO1xyXG4gICAgLy8gRmluZCBmaXJzdCBpbmRleCBvZiBhbiBldmVudCByZWNlbnQgZW5vdWdoIHRvIHJldGFpbiwgdGhlbiBkcm9wIGV2ZXJ5dGhpbmdcclxuICAgIC8vIGF0IGEgbG93ZXIgaW5kZXguXHJcbiAgICBjb25zdCBmaXJzdEdvb2RJbmRleCA9IHBhc3RFdmVudHMuZmluZEluZGV4KGUgPT4gZ2V0QmxvY2tOdW1iZXIoZSkgPiBjdXJyZW50QmxvY2tOdW1iZXIgLSBSRVRBSU5FRF9FVkVOVF9CTE9DS19DT1VOVCk7XHJcbiAgICBpZiAoZmlyc3RHb29kSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgcGFzdEV2ZW50cy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGFzdEV2ZW50cy5zcGxpY2UoMCwgZmlyc3RHb29kSW5kZXgpO1xyXG4gICAgfVxyXG4gICAgcGFzdEV2ZW50cy5wdXNoKGV2ZW50KTtcclxufVxuXG5leHBvcnQgeyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLTc2ZDE1MmU3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-76d152e7.js\n"));

/***/ }),

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9nbG9iYWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lczUtZXh0L2dsb2JhbC5qcz9mYTZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuYWl2ZUZhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZikgcmV0dXJuIHNlbGY7XG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdykgcmV0dXJuIHdpbmRvdztcblx0dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGB0aGlzYFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMpIHJldHVybiB0aGlzO1xuXG5cdC8vIFVuZXhwZWN0ZWQgc3RyaWN0IG1vZGUgKG1heSBoYXBwZW4gaWYgZS5nLiBidW5kbGVkIGludG8gRVNNIG1vZHVsZSlcblxuXHQvLyBGYWxsYmFjayB0byBzdGFuZGFyZCBnbG9iYWxUaGlzIGlmIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsVGhpcykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cblx0Ly8gVGhhbmtzIEBtYXRoaWFzYnluZW5zIC0+IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG5cdC8vIEluIGFsbCBFUzUrIGVuZ2luZXMgZ2xvYmFsIG9iamVjdCBpbmhlcml0cyBmcm9tIE9iamVjdC5wcm90b3R5cGVcblx0Ly8gKGlmIHlvdSBhcHByb2FjaGVkIG9uZSB0aGF0IGRvZXNuJ3QgcGxlYXNlIHJlcG9ydClcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJfX2dsb2JhbF9fXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFVuZm9ydHVuYXRlIGNhc2Ugb2YgdXBkYXRlcyB0byBPYmplY3QucHJvdG90eXBlIGJlaW5nIHJlc3RyaWN0ZWRcblx0XHQvLyB2aWEgcHJldmVudEV4dGVuc2lvbnMsIHNlYWwgb3IgZnJlZXplXG5cdFx0cmV0dXJuIG5haXZlRmFsbGJhY2soKTtcblx0fVxuXHR0cnkge1xuXHRcdC8vIFNhZmFyaSBjYXNlICh3aW5kb3cuX19nbG9iYWxfXyB3b3JrcywgYnV0IF9fZ2xvYmFsX18gZG9lcyBub3QpXG5cdFx0aWYgKCFfX2dsb2JhbF9fKSByZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHRcdHJldHVybiBfX2dsb2JhbF9fO1xuXHR9IGZpbmFsbHkge1xuXHRcdGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG5cdH1cbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es5-ext/global.js\n"));

/***/ }),

/***/ "./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports[\"default\"] = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx3QkFBd0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzP2IzMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmVzb2x2ZWQgdG8gZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dXJkeVdlYlNvY2tldCh1cmwsIHByb3RvY29sc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25kb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OTkVDVElORyA9IFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLk9QRU4gPSBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIHRoaXMuQ0xPU0VEID0gU3R1cmR5V2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdG9jb2xzT3JPcHRpb25zID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3RvY29sc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yID0gV2ViU29ja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IG5vdCBwcmVzZW50IGluIGdsb2JhbCBzY29wZSBhbmQgbm8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIndzQ29uc3RydWN0b3Igb3B0aW9uIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuTmV3V2ViU29ja2V0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJpbmFyeVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCB8fCBcImJsb2JcIjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmluYXJ5VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJidWZmZXJlZEFtb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IHRoaXMud3MgPyB0aGlzLndzLmJ1ZmZlcmVkQW1vdW50IDogMDtcbiAgICAgICAgICAgIHZhciBoYXNVbmtub3duQW1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0RGF0YUJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd25BbW91bnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc1Vua25vd25BbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKFwiU29tZSBidWZmZXJlZCBkYXRhIGhhZCB1bmtub3duIGxlbmd0aC4gYnVmZmVyZWRBbW91bnQoKVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgcmV0dXJuIHZhbHVlIG1heSBiZSBiZWxvdyB0aGUgY29ycmVjdCBhbW91bnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3MgPyB0aGlzLndzLmV4dGVuc2lvbnMgOiB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MucHJvdG9jb2wgOiB0aGlzLmxhc3RLbm93blByb3RvY29sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Nsb3NlZCA/IFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgOiBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KGNvZGUsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaXMgYWxyZWFkeSBpbiBDTE9TSU5HIG9yIENMT1NFRCBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IHRoaXMuT1BFTikge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgcmVjb25uZWN0KCkgb24gc29ja2V0IHdoaWNoIGlzIHBlcm1hbmVudGx5IGNsb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KDEwMDAsIFwiQ2xpZW50IHJlcXVlc3RlZCByZWNvbm5lY3QuXCIpO1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUub3Blbk5ld1dlYlNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGNvbm5lY3RUaW1lb3V0ID0gX2EuY29ubmVjdFRpbWVvdXQsIHdzQ29uc3RydWN0b3IgPSBfYS53c0NvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiT3BlbmluZyBuZXcgV2ViU29ja2V0IHRvIFwiICsgdGhpcy51cmwgKyBcIi5cIik7XG4gICAgICAgIHZhciB3cyA9IG5ldyB3c0NvbnN0cnVjdG9yKHRoaXMudXJsLCB0aGlzLnByb3RvY29scyk7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUNsb3NlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlRXJyb3IoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU9wZW4oZXZlbnQpOyB9O1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgcnVubmluZywgd2Ugc3RpbGwgaGF2ZW4ndCBvcGVuZWQgdGhlIHdlYnNvY2tldC5cbiAgICAgICAgICAgIC8vIEtpbGwgaXQgc28gd2UgY2FuIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0sIGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53cyA9IHdzO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVPcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy53cyB8fCB0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbENsZWFyUmVzZXRUaW1lID0gdGhpcy5vcHRpb25zLmFsbENsZWFyUmVzZXRUaW1lO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IG9wZW5lZC5cIik7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5VHlwZUludGVybmFsID0gdGhpcy53cy5iaW5hcnlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5oYXNCZWVuT3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJyZW9wZW5cIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwib3BlblwiLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5zZW5kKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBfdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBvcGVuVGltZSA9IChhbGxDbGVhclJlc2V0VGltZSAvIDEwMDApIHwgMDtcbiAgICAgICAgICAgIF90aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHJlbWFpbmVkIG9wZW4gZm9yIFwiICsgb3BlblRpbWUgKyBcIiBzZWNvbmRzLiBSZXNldHRpbmdcIiArXG4gICAgICAgICAgICAgICAgXCIgcmV0cnkgdGltZSBhbmQgY291bnQuXCIpO1xuICAgICAgICB9LCBhbGxDbGVhclJlc2V0VGltZSk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJtZXNzYWdlXCIsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1heFJlY29ubmVjdEF0dGVtcHRzID0gX2EubWF4UmVjb25uZWN0QXR0ZW1wdHMsIHNob3VsZFJlY29ubmVjdCA9IF9hLnNob3VsZFJlY29ubmVjdDtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucyA9IHRoaXMud3MuZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSB0aGlzLndzLnByb3RvY29sO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIHRoaXMuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWxsUmVjb25uZWN0ID0gIWV2ZW50IHx8IHNob3VsZFJlY29ubmVjdChldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lsbFJlY29ubmVjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0LCBldmVudCwgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxSZWNvbm5lY3QudGhlbihmdW5jdGlvbiAod2lsbFJlY29ubmVjdFJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0UmVzb2x2ZWQsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJlcnJvclwiLCBldmVudCk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgZW5jb3VudGVyZWQgYW4gZXJyb3IuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVXaWxsUmVjb25uZWN0ID0gZnVuY3Rpb24gKHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBkZW5pYWxSZWFzb24pIHtcbiAgICAgICAgaWYgKHdpbGxSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVlc3RhYmxpc2hDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIGRlbmlhbFJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVlc3RhYmxpc2hDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1pblJlY29ubmVjdERlbGF5ID0gX2EubWluUmVjb25uZWN0RGVsYXksIG1heFJlY29ubmVjdERlbGF5ID0gX2EubWF4UmVjb25uZWN0RGVsYXksIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IgPSBfYS5yZWNvbm5lY3RCYWNrb2ZmRmFjdG9yO1xuICAgICAgICB0aGlzLnJlY29ubmVjdENvdW50Kys7XG4gICAgICAgIHZhciByZXRyeVRpbWUgPSB0aGlzLm5leHRSZXRyeVRpbWU7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IE1hdGgubWF4KG1pblJlY29ubmVjdERlbGF5LCBNYXRoLm1pbih0aGlzLm5leHRSZXRyeVRpbWUgKiByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yLCBtYXhSZWNvbm5lY3REZWxheSkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTsgfSwgcmV0cnlUaW1lKTtcbiAgICAgICAgdmFyIHJldHJ5VGltZVNlY29uZHMgPSAocmV0cnlUaW1lIC8gMTAwMCkgfCAwO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHdhcyBjbG9zZWQuIFJlLW9wZW5pbmcgaW4gXCIgKyByZXRyeVRpbWVTZWNvbmRzICsgXCIgc2Vjb25kcy5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnN0b3BSZWNvbm5lY3RpbmcgPSBmdW5jdGlvbiAoZXZlbnQsIGRlYnVnUmVhc29uKSB7XG4gICAgICAgIHRoaXMuZGVidWdMb2coZGVidWdSZWFzb24pO1xuICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhckFsbFRpbWVvdXRzKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcG9zZVNvY2tldCA9IGZ1bmN0aW9uIChjbG9zZUNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAoIXRoaXMud3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugbm9vcCBoYW5kbGVycyBpbnN0ZWFkIG9mIG51bGwgYmVjYXVzZSBzb21lIFdlYlNvY2tldFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbnMsIHN1Y2ggYXMgdGhlIG9uZSBmcm9tIGlzb21vcnBoaWMtd3MsIHJhaXNlIGEgc3Rpbmsgb25cbiAgICAgICAgLy8gdW5oYW5kbGVkIGV2ZW50cy5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG5vb3A7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoY2xvc2VDb2RlLCByZWFzb24pO1xuICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbFRpbWVvdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hbGxDbGVhclRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hbGxDbGVhclRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnRPZlR5cGUgPSBmdW5jdGlvbiAodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmRvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZW9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbnJlb3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ucmVvcGVuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIF90aGlzLmNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgZXZlbnQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWV2ZW50IHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jYWxsTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kZWJ1Z0xvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IHRoaXMub3B0aW9ucy5tYXhSZWNvbm5lY3RBdHRlbXB0cztcbiAgICAgICAgcmV0dXJuIFwiRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciBcIiArIG1heFJlY29ubmVjdEF0dGVtcHRzICsgXCIgXCIgKyBwbHVyYWxpemUoXCJhdHRlbXB0XCIsIG1heFJlY29ubmVjdEF0dGVtcHRzKSArIFwiLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgYWxsQ2xlYXJSZXNldFRpbWU6IDUwMDAsXG4gICAgICAgIGNvbm5lY3RUaW1lb3V0OiA1MDAwLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIG1pblJlY29ubmVjdERlbGF5OiAxMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3REZWxheTogMzAwMDAsXG4gICAgICAgIG1heFJlY29ubmVjdEF0dGVtcHRzOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHJlY29ubmVjdEJhY2tvZmZGYWN0b3I6IDEuNSxcbiAgICAgICAgc2hvdWxkUmVjb25uZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICB3c0NvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ09OTkVDVElORyA9IDA7XG4gICAgU3R1cmR5V2ViU29ja2V0Lk9QRU4gPSAxO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TSU5HID0gMjtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEID0gMztcbiAgICByZXR1cm4gU3R1cmR5V2ViU29ja2V0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0dXJkeVdlYlNvY2tldDtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9XG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TW2tleV1cbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFVURi0xNiBzdHJpbmdzIHVzZSB0d28gYnl0ZXMgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBOb3RoaW5nLlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sturdy-websocket/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = __webpack_require__(/*! es5-ext/global */ \"./node_modules/es5-ext/global.js\");\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFnQjtBQUN4QyxHQUFHO0FBQ0gsR0FBRztBQUNILHVEQUF1RDtBQUN2RCxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBEQUFXOzs7QUFHM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvYnJvd3Nlci5qcz9lY2NmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZ2xvYmFsVGhpcztcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHtcblx0X2dsb2JhbFRoaXMgPSBnbG9iYWxUaGlzO1xufSBlbHNlIHtcblx0dHJ5IHtcblx0XHRfZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJ2VzNS1leHQvZ2xvYmFsJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdH0gZmluYWxseSB7XG5cdFx0aWYgKCFfZ2xvYmFsVGhpcyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBfZ2xvYmFsVGhpcyA9IHdpbmRvdzsgfVxuXHRcdGlmICghX2dsb2JhbFRoaXMpIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGdsb2JhbCB0aGlzJyk7IH1cblx0fVxufVxuXG52YXIgTmF0aXZlV2ViU29ja2V0ID0gX2dsb2JhbFRoaXMuV2ViU29ja2V0IHx8IF9nbG9iYWxUaGlzLk1veldlYlNvY2tldDtcbnZhciB3ZWJzb2NrZXRfdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5cbi8qKlxuICogRXhwb3NlIGEgVzNDIFdlYlNvY2tldCBjbGFzcyB3aXRoIGp1c3Qgb25lIG9yIHR3byBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIFczQ1dlYlNvY2tldCh1cmksIHByb3RvY29scykge1xuXHR2YXIgbmF0aXZlX2luc3RhbmNlO1xuXG5cdGlmIChwcm90b2NvbHMpIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogJ25hdGl2ZV9pbnN0YW5jZScgaXMgYW4gaW5zdGFuY2Ugb2YgbmF0aXZlV2ViU29ja2V0ICh0aGUgYnJvd3NlcidzIFdlYlNvY2tldFxuXHQgKiBjbGFzcykuIFNpbmNlIGl0IGlzIGFuIE9iamVjdCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzIHdoZW4gY3JlYXRpbmcgYW5cblx0ICogaW5zdGFuY2Ugb2YgVzNDV2ViU29ja2V0IHZpYSAnbmV3IFczQ1dlYlNvY2tldCgpJy5cblx0ICpcblx0ICogRUNNQVNjcmlwdCA1OiBodHRwOi8vYmNsYXJ5LmNvbS8yMDA0LzExLzA3LyNhLTEzLjIuMlxuXHQgKi9cblx0cmV0dXJuIG5hdGl2ZV9pbnN0YW5jZTtcbn1cbmlmIChOYXRpdmVXZWJTb2NrZXQpIHtcblx0WydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTmF0aXZlV2ViU29ja2V0W3Byb3BdOyB9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAndzNjd2Vic29ja2V0JyA6IE5hdGl2ZVdlYlNvY2tldCA/IFczQ1dlYlNvY2tldCA6IG51bGwsXG4gICAgJ3ZlcnNpb24nICAgICAgOiB3ZWJzb2NrZXRfdmVyc2lvblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/websocket/lib/browser.js\n"));

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDRHQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzPzE0MjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/websocket/lib/version.js\n"));

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.35","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.63","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

}]);