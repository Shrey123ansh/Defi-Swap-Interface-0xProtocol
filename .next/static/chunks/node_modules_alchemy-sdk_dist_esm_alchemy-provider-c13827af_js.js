"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_alchemy-sdk_dist_esm_alchemy-provider-c13827af_js"],{

/***/ "./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyProvider\": function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-bb84a433.js */ \"./node_modules/alchemy-sdk/dist/esm/index-bb84a433.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/networks */ \"./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/providers */ \"./node_modules/@ethersproject/providers/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/web */ \"./node_modules/@ethersproject/web/lib.esm/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__._)(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__._)(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_1__.JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        let connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Add user provided overrides if they exist.\r\n        if (config.connectionInfoOverrides) {\r\n            connection = Object.assign(Object.assign({}, connection), config.connectionInfoOverrides);\r\n        }\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.E[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n        this.modifyFormatter();\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.D;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.C) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_3__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.a;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.N).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.N).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.g)(network, apiKey)\r\n            : (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.b)(network, apiKey);\r\n        return {\r\n            headers: _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.I\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.V\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.V,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__._)(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.l)('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.D;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: (0,_index_bb84a433_js__WEBPACK_IMPORTED_MODULE_0__.d)(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overrides the base `Formatter` class inherited from ethers to support\r\n     * returning custom fields in Ethers response types.\r\n     *\r\n     * For context, ethers has a `Formatter` class that is used to format the\r\n     * response from a JSON-RPC request. Any fields that are not defined in the\r\n     * `Formatter` class are removed from the returned response. By modifying the\r\n     * `Formatter` class in this method, we can add support for fields that are\r\n     * not defined in ethers.\r\n     */\r\n    modifyFormatter() {\r\n        this.formatter.formats['receiptLog']['removed'] = val => {\r\n            if (typeof val === 'boolean') {\r\n                return val;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\n\n//# sourceMappingURL=alchemy-provider-c13827af.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS1wcm92aWRlci1jMTM4MjdhZi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwUTtBQUNyTjtBQUNNO0FBQ1o7QUFDMUI7QUFDYTtBQUNuQjtBQUMyQjtBQUNYO0FBQ0c7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsVUFBVSxtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQix1Q0FBdUMsOEJBQThCLDBDQUEwQyxHQUFHO0FBQ3hNO0FBQ0EsbUJBQW1CLDZEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaURBQWM7QUFDcEUsbUJBQW1CLGlEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG1FQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWU7QUFDbEM7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMsaURBQU87QUFDcEQ7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxtQkFBbUIsY0FBYyxpREFBTyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFpQjtBQUMvQixjQUFjLHFEQUFlO0FBQzdCO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0Esa0RBQWtELGlEQUFPO0FBQ3pEO0FBQ0E7QUFDQSxrREFBa0QsaURBQU87QUFDekQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVCxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUF1QjtBQUN0RDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvZXNtL2FsY2hlbXktcHJvdmlkZXItYzEzODI3YWYuanM/OGFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9fYXdhaXRlciwgRCBhcyBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSwgQyBhcyBDdXN0b21OZXR3b3JrcywgYSBhcyBERUZBVUxUX05FVFdPUkssIE4gYXMgTmV0d29yaywgSSBhcyBJU19CUk9XU0VSLCBWIGFzIFZFUlNJT04sIGwgYXMgbG9nV2FybiwgZCBhcyBkZWVwQ29weSwgRSBhcyBFdGhlcnNOZXR3b3JrLCBnIGFzIGdldEFsY2hlbXlIdHRwVXJsLCBiIGFzIGdldEFsY2hlbXlXc1VybCB9IGZyb20gJy4vaW5kZXgtYmI4NGE0MzMuanMnO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L25ldHdvcmtzJztcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tICdAZXRoZXJzcHJvamVjdC93ZWInO1xuaW1wb3J0ICcuL2FwaS91dGlscyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgJ2F4aW9zJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXInO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC93YWxsZXQnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9jb250cmFjdHMnO1xuXG4vKiogTWF4aW11bSBzaXplIG9mIGEgYmF0Y2ggb24gdGhlIHJwYyBwcm92aWRlci4gKi9cclxuY29uc3QgREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFID0gMTAwO1xyXG4vKiogVGltZW91dCBpbnRlcnZhbCBiZWZvcmUgdGhlIHBlbmRpbmcgYmF0Y2ggaXMgc2VudC4gKi9cclxuY29uc3QgREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TID0gMTA7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjbGFzcyB0byBlbnF1ZXVlIHJlcXVlc3RzIGFuZCBhdXRvbWF0aWNhbGx5IHNlbmQvcHJvY2VzcyBiYXRjaGVzLlxyXG4gKlxyXG4gKiBUaGUgdW5kZXJseWluZyBiYXRjaGluZyBtZWNoYW5pc20gaXMgbG9vc2VseSBiYXNlZCBvbiBldGhlcnMuanMnc1xyXG4gKiBgSnNvblJwY0JhdGNoUHJvdmlkZXJgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFJlcXVlc3RCYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNlbmRCYXRjaEZuLCBtYXhCYXRjaFNpemUgPSBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUpIHtcclxuICAgICAgICB0aGlzLnNlbmRCYXRjaEZuID0gc2VuZEJhdGNoRm47XHJcbiAgICAgICAgdGhpcy5tYXhCYXRjaFNpemUgPSBtYXhCYXRjaFNpemU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXJyYXkgb2YgZW5xdWV1ZWQgcmVxdWVzdHMgYWxvbmcgd2l0aCB0aGUgY29uc3RydWN0ZWQgcHJvbWlzZSBoYW5kbGVycyBmb3JcclxuICAgICAgICAgKiBlYWNoIHJlcXVlc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgdGhlIHByb3ZpZGVkIHJlcXVlc3QuIFRoZSBiYXRjaCBpcyBpbW1lZGlhdGVseSBzZW50IGlmIHRoZSBtYXhpbXVtXHJcbiAgICAgKiBiYXRjaCBzaXplIGlzIHJlYWNoZWQuIE90aGVyd2lzZSwgdGhlIHJlcXVlc3QgaXMgZW5xdWV1ZWQgb250byBhIGJhdGNoIHRoYXRcclxuICAgICAqIGlzIHNlbnQgYWZ0ZXIgMTBtcy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNvbHZlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICByZWplY3Q6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoLnB1c2goaW5mbGlnaHRSZXF1ZXN0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoLmxlbmd0aCA9PT0gdGhpcy5tYXhCYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbmQgYmF0Y2ggaW1tZWRpYXRlbHkgaWYgd2UgYXJlIGF0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUuXHJcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBiYXRjaCBmb3IgbmV4dCBldmVudCBsb29wICsgc2hvcnQgZHVyYXRpb25cclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEJhdGNoUmVxdWVzdCgpLCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyB0aGUgY3VycmVudGx5IHF1ZXVlZCBiYXRjaGVzIGFuZCByZXNldHMgdGhlIGJhdGNoIGFuZCB0aW1lci4gUHJvY2Vzc2VzXHJcbiAgICAgKiB0aGUgYmF0Y2hlZCByZXNwb25zZSByZXN1bHRzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHByb21pc2VzLlxyXG4gICAgICovXHJcbiAgICBzZW5kQmF0Y2hSZXF1ZXN0KCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBiYXRjaCBhbmQgY2xlYXIgaXQsIHNvIG5ldyByZXF1ZXN0c1xyXG4gICAgICAgICAgICAvLyBnbyBpbnRvIHRoZSBuZXh0IGJhdGNoXHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5wZW5kaW5nQmF0Y2g7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoID0gW107XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wZW5kaW5nQmF0Y2hUaW1lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaFRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVxdWVzdCBhcyBhbiBhcnJheSBvZiByZXF1ZXN0c1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gYmF0Y2gubWFwKGluZmxpZ2h0ID0+IGluZmxpZ2h0LnJlcXVlc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kQmF0Y2hGbihyZXF1ZXN0KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCByZXN1bHQsIGZlZWQgaXQgdG8gdGhlIGNvcnJlY3QgUHJvbWlzZSwgZGVwZW5kaW5nXHJcbiAgICAgICAgICAgICAgICAvLyBvbiB3aGV0aGVyIGl0IHdhcyBhIHN1Y2Nlc3Mgb3IgZXJyb3JcclxuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcmVzdWx0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaChpbmZsaWdodFJlcXVlc3QgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBTREsncyBjdXN0b20gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGxldCBjb25uZWN0aW9uID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnaHR0cCcpO1xyXG4gICAgICAgIC8vIElmIGEgaGFyZGNvZGVkIHVybCB3YXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlXHJcbiAgICAgICAgLy8gcHJvdmlkZWQgYXBpS2V5IG9yIG5ldHdvcmsuXHJcbiAgICAgICAgaWYgKGNvbmZpZy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIC8vIEFkZCB1c2VyIHByb3ZpZGVkIG92ZXJyaWRlcyBpZiB0aGV5IGV4aXN0LlxyXG4gICAgICAgIGlmIChjb25maWcuY29ubmVjdGlvbkluZm9PdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdGlvbiksIGNvbmZpZy5jb25uZWN0aW9uSW5mb092ZXJyaWRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgZXRoZXJzTmV0d29yayk7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IGNvbmZpZy5iYXRjaFJlcXVlc3RzO1xyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgaW5kaXZpZHVhbCBoZWFkZXJzIHdoZW4gY2FsbGluZyBiYXRjaFxyXG4gICAgICAgIGNvbnN0IGJhdGNoZXJDb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pLCB7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uLmhlYWRlcnMpLCB7ICdBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJzogJ2JhdGNoU2VuZCcgfSkgfSk7XHJcbiAgICAgICAgY29uc3Qgc2VuZEJhdGNoRm4gPSAocmVxdWVzdHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoSnNvbihiYXRjaGVyQ29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlciA9IG5ldyBSZXF1ZXN0QmF0Y2hlcihzZW5kQmF0Y2hGbik7XHJcbiAgICAgICAgdGhpcy5tb2RpZnlGb3JtYXR0ZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgVXJsSnNvblJwY1Byb3ZpZGVyLmdldEFwaUtleWAgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5XHJcbiAgICAgKiBldGhlcnMuanMuIFJldHVybnMgdGhlIEFQSSBrZXkgZm9yIGFuIEFsY2hlbXkgcHJvdmlkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcclxuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiBhcGlLZXkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhcGlLZXkgJyR7YXBpS2V5fScgcHJvdmlkZWQuIGFwaUtleSBtdXN0IGJlIGEgc3RyaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBpS2V5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBCYXNlUHJvdmlkZXIuZ2V0TmV0d29ya2AgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG92ZXJyaWRlIGFsbG93cyB0aGUgU0RLIHRvIHNldCB0aGUgcHJvdmlkZXIncyBuZXR3b3JrIHRvIHZhbHVlcyBub3RcclxuICAgICAqIHlldCBzdXBwb3J0ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmcnICYmIG5ldHdvcmsgaW4gQ3VzdG9tTmV0d29ya3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbU5ldHdvcmtzW25ldHdvcmtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHRoZSBzdGFuZGFyZCBldGhlcnMuanMgZ2V0TmV0d29yayBtZXRob2QgZm9yIG90aGVyIG5ldHdvcmtzLlxyXG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgYE5ldHdvcmtpc2hgIGlucHV0IHRvIHRoZSBuZXR3b3JrIGVudW0gdXNlZCBieSBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QWxjaGVteU5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmIChuZXR3b3JrID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfTkVUV09SSztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV0d29yayAnJHtuZXR3b3JrfScgcHJvdmlkZWQuIE5ldHdvcmsgbXVzdCBiZSBhIHN0cmluZy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR3VhcmFudGVlZCB0aGF0IGB0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZ2AuXHJcbiAgICAgICAgY29uc3QgaXNWYWxpZE5ldHdvcmsgPSBPYmplY3QudmFsdWVzKE5ldHdvcmspLmluY2x1ZGVzKG5ldHdvcmspO1xyXG4gICAgICAgIGlmICghaXNWYWxpZE5ldHdvcmspIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5ldHdvcmsgJyR7bmV0d29ya30nIHByb3ZpZGVkLiBOZXR3b3JrIG11c3QgYmUgb25lIG9mOiBgICtcclxuICAgICAgICAgICAgICAgIGAke09iamVjdC52YWx1ZXMoTmV0d29yaykuam9pbignLCAnKX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXR3b3JrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIENvbm5lY3Rpb25JbmZvfSBvYmplY3QgY29tcGF0aWJsZSB3aXRoIGV0aGVycyB0aGF0IGNvbnRhaW5zXHJcbiAgICAgKiB0aGUgY29ycmVjdCBVUkxzIGZvciBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvKG5ldHdvcmssIGFwaUtleSwgdHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IHR5cGUgPT09ICdodHRwJ1xyXG4gICAgICAgICAgICA/IGdldEFsY2hlbXlIdHRwVXJsKG5ldHdvcmssIGFwaUtleSlcclxuICAgICAgICAgICAgOiBnZXRBbGNoZW15V3NVcmwobmV0d29yaywgYXBpS2V5KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBoZWFkZXJzOiBJU19CUk9XU0VSXHJcbiAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAnQWxjaGVteS1FdGhlcnMtU2RrLVZlcnNpb24nOiBWRVJTSU9OXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgICAgICAnQWxjaGVteS1FdGhlcnMtU2RrLVZlcnNpb24nOiBWRVJTSU9OLFxyXG4gICAgICAgICAgICAgICAgICAgICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFsbG93R3ppcDogdHJ1ZSxcclxuICAgICAgICAgICAgdXJsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBtZXRob2QgaW4gZXRoZXJzLmpzJ3MgYFN0YXRpY0pzb25ScGNQcm92aWRlcmAgY2xhc3MuIFRoaXNcclxuICAgICAqIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiBjYWxsaW5nIG1ldGhvZHMgb24gdGhlIHBhcmVudCBjbGFzcyBgQmFzZVByb3ZpZGVyYC5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZGV0ZWN0TmV0d29yaygpIHtcclxuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcclxuICAgICAgICAgICAgZGV0ZWN0TmV0d29yazogeyBnZXQ6ICgpID0+IHN1cGVyLmRldGVjdE5ldHdvcmsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xyXG4gICAgICAgICAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgX3N1cGVyLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbmV0d29yayBkZXRlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX3N0YXJ0UGVuZGluZygpIHtcclxuICAgICAgICBsb2dXYXJuKCdXQVJOSU5HOiBBbGNoZW15IFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgcGVuZGluZyBmaWx0ZXJzJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgZXRoZXIncyBgaXNDb21tdW5pdHlSZXNvdXJjZSgpYCBtZXRob2QuIFJldHVybnMgdHJ1ZSBpZiB0aGVcclxuICAgICAqIGN1cnJlbnQgYXBpIGtleSBpcyB0aGUgZGVmYXVsdCBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpS2V5ID09PSBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBiYXNlIHtAbGluayBKc29uUnBjUHJvdmlkZXIuc2VuZH0gbWV0aG9kIHRvIGltcGxlbWVudCBjdXN0b21cclxuICAgICAqIGxvZ2ljIGZvciBzZW5kaW5nIHJlcXVlc3RzIHRvIEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1ldGhvZCBUaGUgbWV0aG9kIG5hbWUgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gdXNlIGZvciB0aGUgcmVxdWVzdC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBBZGQgaGVhZGVycyBmb3IgYHBlcmZvcm0oKWAgb3ZlcnJpZGUuXHJcbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQobWV0aG9kLCBwYXJhbXMsICdzZW5kJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEpzb25ScGNQcm92aWRlci5zZW5kKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBjdXN0b20gaGVhZGVyc1xyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfc2VuZChtZXRob2QsIHBhcmFtcywgbWV0aG9kTmFtZSwgZm9yY2VCYXRjaCA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0SWQrKyxcclxuICAgICAgICAgICAganNvbnJwYzogJzIuMCdcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNUQVJUIE1PRElGSUVEIENPREVcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uKTtcclxuICAgICAgICBjb25uZWN0aW9uLmhlYWRlcnNbJ0FsY2hlbXktRXRoZXJzLVNkay1NZXRob2QnXSA9IG1ldGhvZE5hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hSZXF1ZXN0cyB8fCBmb3JjZUJhdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhdGNoZXIuZW5xdWV1ZVJlcXVlc3QocmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgYWN0aW9uOiAncmVxdWVzdCcsXHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxyXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxyXG4gICAgICAgIC8vIGFyZSB0aGUgYmlnZ2VzdCB3aW5zIGFuZCBkbyBub3QgcmVxdWlyZSBhbnkgc2VyaWFsaXppbmcgcGFyYW1ldGVycy5cclxuICAgICAgICBjb25zdCBjYWNoZSA9IFsnZXRoX2NoYWluSWQnLCAnZXRoX2Jsb2NrTnVtYmVyJ10uaW5kZXhPZihtZXRob2QpID49IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW21ldGhvZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Jlc3BvbnNlJyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcclxuICAgICAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gVGhpcyBpcyBkb25lIGJ5IGV0aGVycy5cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBiYXNlIGBGb3JtYXR0ZXJgIGNsYXNzIGluaGVyaXRlZCBmcm9tIGV0aGVycyB0byBzdXBwb3J0XHJcbiAgICAgKiByZXR1cm5pbmcgY3VzdG9tIGZpZWxkcyBpbiBFdGhlcnMgcmVzcG9uc2UgdHlwZXMuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIGNvbnRleHQsIGV0aGVycyBoYXMgYSBgRm9ybWF0dGVyYCBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gZm9ybWF0IHRoZVxyXG4gICAgICogcmVzcG9uc2UgZnJvbSBhIEpTT04tUlBDIHJlcXVlc3QuIEFueSBmaWVsZHMgdGhhdCBhcmUgbm90IGRlZmluZWQgaW4gdGhlXHJcbiAgICAgKiBgRm9ybWF0dGVyYCBjbGFzcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSByZXR1cm5lZCByZXNwb25zZS4gQnkgbW9kaWZ5aW5nIHRoZVxyXG4gICAgICogYEZvcm1hdHRlcmAgY2xhc3MgaW4gdGhpcyBtZXRob2QsIHdlIGNhbiBhZGQgc3VwcG9ydCBmb3IgZmllbGRzIHRoYXQgYXJlXHJcbiAgICAgKiBub3QgZGVmaW5lZCBpbiBldGhlcnMuXHJcbiAgICAgKi9cclxuICAgIG1vZGlmeUZvcm1hdHRlcigpIHtcclxuICAgICAgICB0aGlzLmZvcm1hdHRlci5mb3JtYXRzWydyZWNlaXB0TG9nJ11bJ3JlbW92ZWQnXSA9IHZhbCA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMnc1xyXG4gKiBgQGV0aGVyc3Byb2plY3Qvd2ViL3NyYy50cy9pbmRleC50c2AuIFVzZWQgdG8gc3VwcG9ydFxyXG4gKiB7QGxpbmsgQWxjaGVteVByb3ZpZGVyLl9zZW5kfSwgd2hpY2ggaXMgYWxzbyBjb3BpZWQgb3Zlci5cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XHJcbiAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcclxuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xyXG59XG5cbmV4cG9ydCB7IEFsY2hlbXlQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci1jMTM4MjdhZi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alchemy-sdk/dist/esm/alchemy-provider-c13827af.js\n"));

/***/ })

}]);